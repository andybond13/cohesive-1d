/*******************************************************************************

  Class <cartRing> 

  Author: Martin Hautefeuille
          Duke Computational Mechanics Lab (DCML)
          Duke University - Durham, NC (USA)
  E-mail: mh186@duke.edu

  Copyright (c) 2010 Martin Hautefeuille. All rights reserved. No warranty. No
  liability.

*******************************************************************************/
#include "cartRing.h"
#include "mpi.h"
#include <stdlib.h>
#include <time.h>
#include <iostream>
#include <numeric>
#include <fstream>
#include <stdio.h>
#include <assert.h>
#include <math.h>
#include <sys/stat.h>
//#include <str_ops.hpp>
#include <time.h>
//#include <valarray>
using namespace std;
using namespace MPI;

#define PI 3.14159265358979323846

/*******************************************************************************

                M E T H O D S    F O R    R E S O L U T I O N 

*******************************************************************************/

/*------------------------------- P U B L I C --------------------------------*/

CartRing::CartRing ( const double length, const double crossSec,
                     const double density, const double YoungMod,
                     const int nodNum, const std::string path  ) {


	//begin parallel specification
	MPI::Init(); 
	_numprocs = MPI::COMM_WORLD.Get_size(); 
	_myid = MPI::COMM_WORLD.Get_rank(); 
	MPI::COMM_WORLD.Barrier();

    // affect input values to attributes
    _L = length;
    _A = crossSec;
    _rho = density;
    _E = YoungMod;
    _Nx = nodNum;
    _R0 = _L/(2*PI);
    _c = sqrt( _E / _rho );
    _path = path;
	_defectRange = -1.0;

	//domain decomposition
	domainDecomposition();	

     //Initialize time clock to generate time stamp for log filename
	time_t rawtime;
	time ( &rawtime );
	struct tm * tinf = localtime ( &rawtime );

	//initialize clock for run-time calculation
	std::clock_t _start;
	_start = std::clock();

     // name for the log file
     std::string minutes = ( tinf->tm_min < 10 )
                         ? "0"+convertInt(tinf->tm_min)
                         : convertInt(tinf->tm_min);
    _logPath = _path + "/cartRing" + convertInt( _Nx ) + "_"
             + convertInt( tinf->tm_mon+1 ) + "-"
             + convertInt( tinf->tm_mday+0 ) + "-"
             + convertInt( tinf->tm_year+1900 ) + "_"
             + convertInt( tinf->tm_hour ) + ":"
             + minutes + "_p" + convertInt(_myid) + ".log";

	// clean the directory tree
	printClean();
	std::string shellCmd = _path+"/clean.sh";

	if (_myid == 0) {

		FILE * pFile;
		pFile = fopen ( _logPath.c_str(), "w" );	//Try to create logfile
		if ( !pFile ) {				//Create structure if it doesn't exist
		    // create the directory tree
		    mkdir( _path.c_str(), 0777 );		//allow read, write, execute for all users
		    std::string datPath = _path+"/datFiles";
		    mkdir( datPath.c_str(), 0777 );
		    std::string pngPath = _path+"/pngFiles";
		    mkdir( pngPath.c_str(), 0777 );
		    std::string gnuPath = _path+"/gnuplot";
		    mkdir( gnuPath.c_str(), 0777 );
		    std::string vtkPath = _path+"/vtkFiles";
		    mkdir( vtkPath.c_str(), 0777 );
		    //printClean();
		    pFile = fopen( _logPath.c_str(), "w" );	//reopen
		} else {
		    /*// clean the directory tree
		    printClean();
		    std::string shellCmd = _path+"/clean.sh";*/

			//make sure clean.sh exists
			fstream myFile(shellCmd.c_str());
			if (!myFile.good()) printClean();
			system( shellCmd.c_str() );
		}
		//Print logfile title block
		fprintf ( pFile, "## Log file for cartring.h\n" );
		fprintf ( pFile, "##   Number of elements: %u\n", _Nx );
		fprintf ( pFile, "##   Start on: %s\n\n", asctime( tinf ) );
		fclose( pFile );

	}

    // build the mesh
    buildDiscretization ();

    // set _DisplayFlag and _tFlag to false and zero
    _DisplayFlag = false;
    _tFlag.resize(2);
    _tFlag[0] = 0;
    _tFlag[1] = 0;
}

//Empty constructor for CTL
CartRing::CartRing() {}

//Destructor
CartRing::~CartRing () {
	if (_myid == 0) {
		// create a plot file if necessary
		if ( _NodesToPlot.size() != 0 || _ElmsToPlot.size() != 0 ) {
		    std::string plotFil = _path+"/plot.sh";		//"../results/plot.sh"
		    FILE * pFileP;
		    pFileP = fopen( plotFil.c_str(), "w" );
		    fprintf( pFileP, "#!/bin/bash\n" );
		    fprintf( pFileP, "# shell script generated by <ring.h>" );
		    fprintf( pFileP, " -- MH [DCML] (2010)\n\n" );
		    if ( _NodesToPlot.size() != 0 ) {
		        std::string velRFil = "./gnuplot/plotRadialVelo.plt";
		        fprintf( pFileP, "gnuplot %s\n", velRFil.c_str() );
		        std::string velTFil =  "./gnuplot/plotCircumVelo.plt";
		        fprintf( pFileP, "gnuplot %s\n", velTFil.c_str() );
		    }
		    if ( _ElmsToPlot.size() != 0 ) {
		        std::string streFil = "./gnuplot/plotStre.plt";
		        fprintf( pFileP, "gnuplot %s\n", streFil.c_str() );
		    }
		    if ( _EnrgFile.size() != 0 ) {
		        std::string enrgFil = "./gnuplot/plotEnrg.plt";
		        fprintf( pFileP, "gnuplot %s\n", enrgFil.c_str() );
		    }
		    if ( _CohLawFile.size() != 0 ) {
		        std::string cohLawFil = "./gnuplot/plotCohLaw.plt";
		        fprintf( pFileP, "gnuplot %s\n", cohLawFil.c_str() );
		    }
		    if ( _FragFile.size() != 0 ) {
		        std::string fragFil = "./gnuplot/plotFragInfo.plt";
		        fprintf( pFileP, "gnuplot %s\n", fragFil.c_str() );
		    }
		    if ( _HistoFile.size() != 0 ) {
		        std::string histoFil = "./gnuplot/plotHisto.plt";
		        fprintf( pFileP, "gnuplot %s\n", histoFil.c_str() );
		    }
		    if ( _SThetaFile.size() != 0 ) {
		        std::string sThetaFil = "./gnuplot/plotSTheta.plt";
		        fprintf( pFileP, "gnuplot %s\n", sThetaFil.c_str() );
		    }
		    fprintf( pFileP, "\n/usr/bin/open -a \"/Applications/Google Chrome.app\" ./pngFiles/*.svg &\n" );
		    fclose( pFileP );
		    chmod( plotFil.c_str(), 0775 );
		}
	}
}

void CartRing::setCohLaw ( const std::string& lawTyp,
                           const std::vector<std::vector<double> >& param ) {

	//save cohesive law type
	_lawTyp = lawTyp;

	//assume downward linear / Ortiz form
    //If sigma (maximum traction) and delta (final opening) are specified
    if ( lawTyp.compare( 0 , 5, "LINSD" ) == 0 ) {
        if ( param.size() >= 2 ) {
            // _SigC
            if ( param[0].size() == 1 ) {
                _SigC.assign( _Nx, param[0][0] );
            } else if ( param[0].size() == _Nx ) {
                _SigC.assign( param[0].begin(), param[0].end() );
            } else {
                std::cout << "param[0].size() and # of cohesive links "
                          << "mismatch!!\n"
                          << "only the first value " << param[0][0]
                          << " is considered for all the elements"
                          << std::endl;
                _SigC.assign( _Nx, param[0][0] );
            }
            // _DelC
            if ( param[1].size() == 1 ) {
                _DelC.assign( _Nx, param[1][0] );
            } else if ( param[1].size() == _Nx ) {
                _DelC.assign( param[1].begin(), param[1].end() );
            } else {
                std::cout << "param[1].size() and # of cohesive links"
                          << " mismatch!!\n"
                          << "only the first value " << param[1][0]
                          << " is considered for all the elements"
                          << std::endl;
                _DelC.assign( _Nx, param[1][0] );
            }
        } else {
             std::cout << "LINSD requires two parameters sigma_c and delta_c"
                       << std::endl; 
	     	assert(1==0);
        }
    } else if ( lawTyp.compare( 0, 5, "LINSG" ) == 0 ) {		//if sigma and energy are specified
        if ( param.size() >= 2 ) {
            // _SigC
            if ( param[0].size() == 1 ) {
                _SigC.assign( _Nx, param[0][0] );
            } else if ( param[0].size() == _Nx ) {
                _SigC.assign( param[0].begin(), param[0].end() );
            } else {
                std::cout << "param[0].size() and # of cohesive links"
                          << " mismatch!!\n"
                          << "only the first value " << param[0][0]
                          << " is considered for all the elements"
                          << std::endl;
                _SigC.assign( _Nx, param[0][0] );
            }
            // _DelC
            if ( param[1].size() == _Nx ) {
                _DelC.resize( _Nx );
                if ( param[0].size() != _Nx ) {
                    for ( unsigned i = 0; i < _Nx; i++ ) {
                        _DelC[i] = 2 * param[1][i] / param[0][0];	//Gc = sigma*delta/2; delta=2*Gc/s
                    }
                } else {
                    for ( unsigned i = 0; i < _Nx; i++ ) {
                        _DelC[i] = 2 * param[1][i] / param[0][i];
                    }
                }
            } else {
                if ( param[0].size() != _Nx ) {
                    _DelC.assign( _Nx, 2 * param[1][0] / param[0][0] );
                } else {
                    _DelC.resize( _Nx );
                    for ( unsigned i = 0; i < _Nx; i++ ) {
                        _DelC[i] = 2 * param[1][0] / param[0][i];
                    }
                }
                if ( param[1].size() != 1 ) {
                    std::cout << "param[1].size() and # of cohesive links"
                              << " mismatch!!\n"
                              << "only the first value " << param[1][0]
                              << " is considered for all the elements"
                              << std::endl;
                }
            }
        } else {
             std::cout << "LINSG requires two parameters sigma_c and delta_c"
                       << std::endl; 
			assert(1==0);
        }
	} else if ( lawTyp.compare( 0, 6, "SQRTSG" ) == 0 ) {		//if sigma and energy are specified - square root curve - Nicholas Moes TLS-based
        if ( param.size() >= 2 ) {
            // _SigC
            if ( param[0].size() == 1 ) {
                _SigC.assign( _Nx, param[0][0] );
            } else if ( param[0].size() == _Nx ) {
                _SigC.assign( param[0].begin(), param[0].end() );
            } else {
                std::cout << "param[0].size() and # of cohesive links"
                          << " mismatch!!\n"
                          << "only the first value " << param[0][0]
                          << " is considered for all the elements"
                          << std::endl;
                _SigC.assign( _Nx, param[0][0] );
            }
            // _DelC
            if ( param[1].size() == _Nx ) {
                _DelC.resize( _Nx );
                if ( param[0].size() != _Nx ) {
                    for ( unsigned i = 0; i < _Nx; i++ ) {
                        _DelC[i] = 3 * param[1][i] / param[0][0];	//Gc = sigma*delta/3; delta=3*Gc/sigmac
                    }
                } else {
                    for ( unsigned i = 0; i < _Nx; i++ ) {
                        _DelC[i] = 3 * param[1][i] / param[0][i];
                    }
                }
            } else {
                if ( param[0].size() != _Nx ) {
                    _DelC.assign( _Nx, 3 * param[1][0] / param[0][0] );
                } else {
                    _DelC.resize( _Nx );
                    for ( unsigned i = 0; i < _Nx; i++ ) {
                        _DelC[i] = 3 * param[1][0] / param[0][i];
                    }
                }
                if ( param[1].size() != 1 ) {
                    std::cout << "param[1].size() and # of cohesive links"
                              << " mismatch!!\n"
                              << "only the first value " << param[1][0]
                              << " is considered for all the elements"
                              << std::endl;
                }
            }
        } else {
             std::cout << "SQRTSG requires two parameters sigma_c and delta_c"
                       << std::endl; 
			assert(1==0);
        }

    } else {
        std::cout << lawTyp << " has not yet been implemented!!" << std::endl;
		assert(1==0);
    }

    // resize _ActivCoh, _D, _delta, _and _sigCoh to be size of # of cohesive zones: Nx-1
    _ActivCoh.assign( _Nx, false );
    _D.resize( _Nx );
    _delta.resize( _Nx );
    _sigCoh.resize( _Nx );
    for ( unsigned i = _begin; i <= _end; i++ ) {
        _D[i].resize(2);
    }
}

void CartRing::applyVel (  const std::string& velDir, const double strainRate  ) {
    for ( unsigned i = 0; i < _Vel.size(); i++ ) {
        if (!_local[i]) continue;
        _Vel[i][0][0] = 0.0;//initialize velocity
        _Vel[i][0][1] = 0.0;
    }

    //Constant Strain Rate Case
    if ( velDir.compare( 0, 8, "CONST_SR") == 0 ) {	//a radial velocity - Assign direction and value to VVBC
        _ValVelBC[0] = 0;
        _ValVelBC[1] = strainRate; //target strain rate
        //initialize velocity
        double energy = 0.0;
        for ( unsigned i = 0; i < _Vel.size(); i++ ) {
		    if (!_local[i]) continue;
            _Vel[i][0][0] = _NodPosOrig[i][0] * strainRate;
            energy += 0.5 * _m * _Vel[i][0][0] * _Vel[i][0][0];
        }
        if (_myid == 0) _Wext += energy;
    } else if ( velDir.compare( 0, 11, "CONST_ENDSR") == 0 ) {	//a radial velocity - Assign direction and value to VVBC
        _ValVelBC[0] = 3;
        _ValVelBC[1] = strainRate; //target strain rate
        //initialize velocity
        double energy = 0.0;
        for ( unsigned i = 0; i < _Vel.size(); i++ ) {
		    if (!_local[i]) continue;
            _Vel[i][0][0] = _NodPosOrig[i][0] * strainRate;
            energy += 0.5 * _m * _Vel[i][0][0] * _Vel[i][0][0];
        }
        if (_myid == 0) _Wext += energy;
    } else if ( velDir.compare( 0, 9, "CONST_VEL") == 0 ) {	//a radial velocity - Assign direction and value to VVBC
        _ValVelBC[0] = 2;
        _ValVelBC[1] = strainRate; //target velocity
        _Vel[2*_Nx-1][0][0] = strainRate;
        if (_myid == 0) _Wext += 0.5 * _m * strainRate * strainRate;
    } else {
        std::cout << "Direction " << velDir << " unknown! " << std::endl; 
		assert(1==0);
    }
}

void CartRing::applyForc ( const double forcVal  ) {
    //applied force on end
    for ( unsigned i = 0; i < _Vel.size(); i++ ) {
        if (!_local[i]) continue;
        _Vel[i][0][0] = 0.0;//initialize velocity
        _Vel[i][0][1] = 0.0;
    }

    _ValVelBC[0] = 1;
    _ValVelBC[1] = forcVal;
}

void CartRing::solve ( const double endTime, const unsigned printFrequency, const double refine, const bool allowPlateauEnd, const bool checkEnergy ) {

	//set some global variables
	_allowPlateauEnd = allowPlateauEnd;
	_checkEnergy = checkEnergy;

	//synchronize
	MPI::COMM_WORLD.Barrier();

    // Print stuff to vtk file
    if ( _DisplayFlag ) {
        printVtk( _Nt );
    }

	//begin time-step loop
    while (( _T < endTime ) && (_stopFlag == false)) {

		//synchronize
		MPI::COMM_WORLD.Barrier();

        // Compute the time-step
        /*
            _Dt = alpha * _Dt_c with 0.8 < alpha < 0.98
            see [Belytschko, pp. 315]
        */ 
        _Dt = 0.8 * _Dt_c;
		timeStepRefine(refine);		//refine timestep if needed using the time-step flags.

        // Increase current time and time-step, update time-step flags
        _Nt++;
        _T += _Dt;
		_tFlag[0] = _tFlag[1];	//save current time-step flag
		_tFlag[1] = 0;		//initialize new time-step flag
		_stopFlag = false;	//initialize stop flag

        // Explicit Newmark
        MPI::COMM_WORLD.Barrier(); NewmarkPred();
        MPI::COMM_WORLD.Barrier(); NewmarkReso();
        MPI::COMM_WORLD.Barrier(); NewmarkCorr();

		//Check stability and decide on adaptive time-stepping
	 	checkStable();

		//Count the number of fragments
		fragCount();

        // Energy balance check
        energBalance();

        // Update
		MPI::COMM_WORLD.Barrier();
        update();
		MPI::COMM_WORLD.Barrier();
        // Print stuff
        if ( _DisplayFlag ) {
			if (_numFrag >= 1) {
//		    		if ( _Nt % (static_cast<int>(mult)*_DtPrintFrac) == 0 ) {	//Use fracture print frequency
		    		if ( fmod(_T, 0.25*_Dt_c*_DtPrintFrac)-fmod(_T+_Dt, 0.25*_Dt_c*_DtPrintFrac) > _Dt ) {	//Use fracture print frequency
		                printVtk( _Nt );
				}
			} else {
//		    	    if ( _Nt % (static_cast<int>(mult)*_DtPrintElas) == 0 ) {	//Use elastic print frequency
		    		if ( fmod(_T, 0.25*_Dt_c*_DtPrintFrac)-fmod(_T+_Dt, 0.25*_Dt_c*_DtPrintFrac) > _Dt ) {	//Use fracture print frequency
		     	   printVtk( _Nt );
				}
            }
        }
		//print stress vs. theta graphs
        if ( _Nt % _Nx == 0 ) {
	    		printSTheta();
		}

		//print the rest of the table/graph data
		if ( (( _Nt - 1 ) % printFrequency) == 0 ) {
		        printNodalInfo();
		        printElmInfo();
			printCohLaw();
		        printFrags();
			printGlobalInfo();
		}

		//synchronize
		MPI::COMM_WORLD.Barrier();
    }

	if (_myid == 0 ) {
		std::cout << "---------------------------" << std::endl;
		std::cout << "Execution Finished" << std::endl;
		std::cout << "Number of Fragments:   " << numFragSymm() << std::endl;
		std::cout << "Number of Iterations:  " << _Nt << std::endl;
		std::cout << "Final Cohesive Energy: " << _Wcoh[0] << std::endl;
		std::cout << "Final Stability Ratio: " << _Wsum / _Wmax << std::endl;
		std::cout << "---------------------------" << std::endl;

		//Determine finishing time
		time_t rawtime;
		time ( &rawtime );
		struct tm * tinf = localtime ( &rawtime );

		//Close out log file
		FILE * pFile;
		pFile = fopen ( _logPath.c_str(), "a" );
		fprintf( pFile, "\n\n## Execution finished\n" );
		fprintf( pFile, "##    time: %s", asctime( tinf ) );
		fprintf( pFile, "##    number of fragments: %u\n", numFragSymm() );
		fprintf( pFile, "##    number of iterations: %u\n", _Nt );
		fprintf( pFile, "##    final cohesive energy: %e\n", _Wcoh[0] );
		fprintf( pFile, "##    final stability ratio: %e\n", _Wsum/_Wmax );
		fclose( pFile );
	}

	//end parallel run
	MPI::COMM_WORLD.Barrier(); MPI::COMM_WORLD.Allreduce ( &_WsprD, &_WsprD, 1, MPI::DOUBLE, MPI_SUM);
	MPI::Finalize(); 

}

unsigned CartRing::numFragSymm() {
    if (_numFrag == 0)
        return 1;
    if (_D[0][1] >= 1) 
        return 2 * _numFrag;
    else
        return 2 * _numFrag + 1;
}

void CartRing::printHisto() {
	if (_myid > 0) return;

    // Prints Histogram and scaled 1-cdf figure
    if (_numFrag > 1) {
        plotHisto();
		_fragInvCDF.resize(2);
		_fragInvCDF[0].resize(1000);	//a length, from zero to the max. fragment size
		_fragInvCDF[1].resize(1000);	//number of fragments larger than this length
		_fHisto.assign(25, 0);		//number of bins for the fragment histogram
	
		//Histogram - 25 bins
		 double max = _fMax;	//size
		//Step through fragment length list; increase count in the bin if fragment fits
		for (unsigned k = 0; k < _fragLength.size(); k++){
			if (_fragLength[k] < max * 0.04){
			_fHisto[0] += 1;
			}
			if ((_fragLength[k] < max * 0.08) && (_fragLength[k] >= max * 0.04)) {
			_fHisto[1] += 1;
			}
			if ((_fragLength[k] < max * 0.12) && (_fragLength[k] >= max * 0.08)) {
			_fHisto[2] += 1;
			}
			if ((_fragLength[k] < max * 0.16) && (_fragLength[k] >= max * 0.12)) {
			_fHisto[3] += 1;
			}
			if ((_fragLength[k] < max * 0.20) && (_fragLength[k] >= max * 0.16)) {
			_fHisto[4] += 1;
			}
			if ((_fragLength[k] < max * 0.24) && (_fragLength[k] >= max * 0.20)) {
			_fHisto[5] += 1;
			}
			if ((_fragLength[k] < max * 0.28) && (_fragLength[k] >= max * 0.24)) {
			_fHisto[6] += 1;
			}
			if ((_fragLength[k] < max * 0.32) && (_fragLength[k] >= max * 0.28)) {
			_fHisto[7] += 1;
			}
			if ((_fragLength[k] < max * 0.36) && (_fragLength[k] >= max * 0.32)) {
			_fHisto[8] += 1;
			}
			if ((_fragLength[k] < max * 0.40) && (_fragLength[k] >= max * 0.36)) {
			_fHisto[9] += 1;
			}
			if ((_fragLength[k] < max * 0.44) && (_fragLength[k] >= max * 0.40)) {
			_fHisto[10] += 1;
			}
			if ((_fragLength[k] < max * 0.48) && (_fragLength[k] >= max * 0.44)) {
			_fHisto[11] += 1;
			}
			if ((_fragLength[k] < max * 0.52) && (_fragLength[k] >= max * 0.48)) {
			_fHisto[12] += 1;
			}
			if ((_fragLength[k] < max * 0.56) && (_fragLength[k] >= max * 0.52)) {
			_fHisto[13] += 1;
			}
			if ((_fragLength[k] < max * 0.60) && (_fragLength[k] >= max * 0.56)) {
			_fHisto[14] += 1;
			}
			if ((_fragLength[k] < max * 0.64) && (_fragLength[k] >= max * 0.60)) {
			_fHisto[15] += 1;
			}
			if ((_fragLength[k] < max * 0.68) && (_fragLength[k] >= max * 0.64)) {
			_fHisto[16] += 1;
			}
			if ((_fragLength[k] < max * 0.72) && (_fragLength[k] >= max * 0.68)) {
			_fHisto[17] += 1;
			}
			if ((_fragLength[k] < max * 0.76) && (_fragLength[k] >= max * 0.72)) {
			_fHisto[18] += 1;
			}
			if ((_fragLength[k] < max * 0.80) && (_fragLength[k] >= max * 0.76)) {
			_fHisto[19] += 1;
			}
			if ((_fragLength[k] < max * 0.84) && (_fragLength[k] >= max * 0.80)) {
			_fHisto[20] += 1;
			}
			if ((_fragLength[k] < max * 0.88) && (_fragLength[k] >= max * 0.84)) {
			_fHisto[21] += 1;
			}
			if ((_fragLength[k] < max * 0.92) && (_fragLength[k] >= max * 0.88)) {
			_fHisto[22] += 1;
			}
			if ((_fragLength[k] < max * 0.96) && (_fragLength[k] >= max * 0.92)) {
			_fHisto[23] += 1;
			}
			if ((_fragLength[k] <= max) && (_fragLength[k] >= max * 0.96)) {
			_fHisto[24] += 1;
			}
		}

		//Open file to record histogram and 1-cdf data
		if ( _HistoFile.size() > 0 ) {
			FILE * pFile;
			pFile = fopen( _HistoFile.c_str(), "a" );
			double j = 0;
			for (unsigned i = 0; i < 1000; i++) {

				//grab the 1-cdf data; 
				unsigned count = 0;
				j = max * (i / 1000.0);	//from 0 to max length, 1000 increments
				for (unsigned k = 0; k < _numFrag; k++) {
					if (_fragLength[k] > j) {		//if frag length greater than j, add to count
						count += 1;
					}
				}
		
				//save to vector
				_fragInvCDF[0][i] = j;
				_fragInvCDF[1][i] = (double)count;
				fprintf( pFile, "%12.3e %u", j, count);		//print to file

				//print histogram info to file - relative size (% of max frag length) & count
				if (i < 25) {	//piggybacking the for loop, only need the first 25
					fprintf( pFile, " %f %u", (double)(i*4+2), _fHisto[i] );
				} else {
					fprintf( pFile, " 0 0");
				}
				fprintf( pFile, "\n" );
			}


			//print raw fragment sizes to file
			fprintf( pFile, "Sizes: \n" );
			for (unsigned k = 0; k < _fragLength.size(); k++){
				fprintf( pFile, "%12.3e \n", _fragLength[k] );
			}

			fclose( pFile );
		}
    }
}

void CartRing::grabInfo (double& runTime, unsigned& numFrag, unsigned& nIter, double& Wcoh0, double& Wsum,
				double& Wmax, std::vector<double>& fragLength, double& meanFragLength, double& WsprD,
				std::vector<unsigned>& fHisto, std::vector<std::vector<double> >& fragInvCDF){
    //Grabs information from a completed run and returns it to the post-processor
    //Returns all values
	if (_myid > 0) return;
    runTime = ( (double)std::clock() - (double)_start ) / (double) CLOCKS_PER_SEC;
    numFrag = numFragSymm();
    nIter = _Nt;
    Wcoh0 = _Wcoh[0];
    Wsum = _Wsum;
    Wmax = _Wmax;
    WsprD = _WsprD;
    fragLength = _fragLength;
    meanFragLength = _fMean;
    fHisto = _fHisto;
    fragInvCDF = _fragInvCDF;
    
}

void CartRing::grabInfo (double& runTime, unsigned& numFrag, unsigned& nIter, double& Wcoh0, double& Wsum,
				double& Wmax, double& meanFragLength, double& WsprD){
    //Grabs information from a completed run and returns it to the post-processor
    //Returns doubles only
	if (_myid > 0) return;
    runTime = ( (double)std::clock() - (double)_start ) / (double) CLOCKS_PER_SEC;
    numFrag = numFragSymm();
    nIter = _Nt;
    Wcoh0 = _Wcoh[0];
    Wsum = _Wsum;
    Wmax = _Wmax;
    meanFragLength = _fMean;
    WsprD = _WsprD;
    
}

void CartRing::defectLimit (const double& defectRange) {
    //Assign defect limit range as a global variable
    _defectRange = defectRange;
}

/*------------------------------ P R I V A T E -------------------------------*/

void CartRing::domainDecomposition() {

	_local = vector<unsigned>(2*_Nx);				//list of locally-owned nodes (boolean: 1 = local, 0 = not)
	_owner = vector<unsigned>(2*_Nx);				//list of owner of nodes
	vector<unsigned> owner = vector<unsigned>(2*_Nx); //list of owner of nodes - local, used to build global one
	_begin = (_myid*_Nx)/_numprocs;			//first node that this processor owns
	_end = ((_myid+1)*_Nx)/_numprocs-1; 		//last node that this processor owns

	//assign whether the node is to be owned locally or not
	for (unsigned i = 0; i < 2*_Nx; ++i) {
	
		if (i >= 2*_begin+1 && i <= 2*_end+2) {
			_local[i] = true;
			owner[i] = _myid;
		} else {
			_local[i] = false;
		}
	}
	
	//distribute who owners of nodes are
	//synchronize
	MPI::COMM_WORLD.Barrier();
	MPI::COMM_WORLD.Allreduce (&owner[0] , &_owner[0] , (int)2*_Nx , MPI::INT ,MPI::SUM);
	
	//check that everything lines up locally	 
	for (unsigned i = 0; i < 2*_Nx; ++i) { 
		if (_local[i]) assert(_owner[i] == _myid);
	}

	//synchronize
	MPI::COMM_WORLD.Barrier();

}

std::string CartRing::convertInt(int number) const
{
    if (number == 0)
        return "0";
    string temp="";
    string returnvalue="";
	//read from back
    while (number>0)
    {
        temp+=number%10+48;
        number/=10;
    }
    for (unsigned i=0;i<temp.length();i++)
        returnvalue+=temp[temp.length()-i-1];
    return returnvalue;
}

void CartRing::buildDiscretization () {
    //this has been converted from axisymmetricRing->flaming-avenger so that it is linear, x = [0,L];

    // Build _NodPos, assign node locations
    _NodPos.resize( 2*_Nx ); 		//node locations[node number][x or y]
    _NodPosOrig.resize( 2*_Nx ); 
    for ( unsigned i = 1; i <= _Nx; i++ ) { 
        unsigned k = 2*i-2;
        unsigned j = 2*i-1;
        _NodPos[j].resize( 2 ); 
        _NodPos[k].resize( 2 ); 
        _NodPosOrig[j].resize( 2 ); 
        _NodPosOrig[k].resize( 2 ); 
        double thetaK = static_cast<double>(i-1)/_Nx; 
        double thetaJ = static_cast<double>(i)/_Nx; 
        _NodPos[j][0] = _L*thetaJ;
        _NodPos[j][1] = 0.0; 
        _NodPos[k][0] = _L*thetaK;
        _NodPos[k][1] = 0.0; 
        _NodPosOrig[j][0] = _L*thetaJ;; 
        _NodPosOrig[j][1] = 0.0; 
        _NodPosOrig[k][0] = _L*thetaK;; 
        _NodPosOrig[k][1] = 0.0; 
    } 

    // Build connectivities - assign nodes to springs and links
    _SprCon.resize( _Nx );
    _CohCon.resize( _Nx );
    _NodCon.resize( _NodPos.size() );
    for ( unsigned i = 0; i < _Nx; i++ ) {
        // Build _SpringConnec and _NodeConnec accordingly
        _SprCon[i].first = 2*i;
        _NodCon[2*i].first = i;
        _SprCon[i].second = 2*i+1;
        _NodCon[2*i+1].first = i;

        // Build _CoheJointConnec and _NodeConnec accordingly
        int k = 2*i+1-2;
        unsigned j = 2*i+2-2;
        _CohCon[i].first = k;
        _NodCon[j].second = i;
        _CohCon[i].second = j;
        _NodCon[k].second = i;
    }
    printConnec();	//print table of connections for for small meshes

    // Compute the element size
    std::vector<double> firstElmVec = sprVec ( 0 );
    _Dx = sqrt( pow( firstElmVec[0], 2 ) + pow( firstElmVec[1], 2 ) );	//initial element size
    _m = 0.5 * _rho * _A * _Dx;						//element half-mass, nodal mass

    // Compute critical time-step
    _Dt_c = _Dx / _c;

    // Resize the kinematics
    _Dis.resize( _NodPos.size() );		//displacement[node #][initial, predict, correct][x or y]
    _Vel.resize( _NodPos.size() );
    _Acc.resize( _NodPos.size() );
    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
        _Dis[i].resize( 3 );
        _Dis[i][0].resize( 2 );
        _Dis[i][1].resize( 2 );
        _Dis[i][2].resize( 2 );
        _Vel[i].resize( 3 );
        _Vel[i][0].resize( 2 );
        _Vel[i][1].resize( 2 );
        _Vel[i][2].resize( 2 );
        _Acc[i].resize( 2 );
        _Acc[i][0].resize( 2 );
        _Acc[i][1].resize( 2 );
    }

    // Resize forces
    _Fspr.resize( _NodPos.size() );
    _Fcoh.resize( _NodPos.size() );
    _Fext.resize( _NodPos.size() );
    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
        _Fspr[i].resize( 2 );
        _Fcoh[i].resize( 2 );
        _Fext[i].resize( 2 );
        _Fext[i][0].resize( 2 );
        _Fext[i][1].resize( 2 );
    }

    // Resize dual variables
    _Stress.resize( _Nx );
    _sprDamage.assign(_Nx,0.0);

    // Resize & initialize _Wcoh & _Wspr & _Wsum & _numFrag & _DSum & _stopFlag
    _Wcoh.resize(2);
    _dWcoh.assign(5,0.0);
    _Wcoh100.assign(4,0.0);
    _Wspr = 0;
    _Wsum = 0;
    _Wext = 0.0;
    _numFrag = 0;
    _DSum = 0;
    _stopFlag = false;

    // Resize vectors for BC
    _ValVelBC.resize(2);
    _VelForcReq.resize( _NodPos.size() );
    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
        _VelForcReq[i].resize( 2 );
    }

    // Set _T and _Nt to zero
    _T = 0.0;
    _Nt = 0; 

	//define boundary nodes
	defineBoundaryNodes();
	MPI::COMM_WORLD.Barrier();

}

void CartRing::NewmarkPred () {

    for ( unsigned i = 0; i < 2*_Nx; i++ ) {
		if (!_local[i]) continue;

        // Predict Velocities
        _Vel[i][1][0] = _Vel[i][0][0] + 0.5 * _Dt * _Acc[i][0][0];
        _Vel[i][1][1] = _Vel[i][0][1] + 0.5 * _Dt * _Acc[i][0][1];

        // Apply Boundary Conditions
        /* NOT YET SURE ON HOW TO DO IT */
        // Predict relative displacements
        _Dis[i][1][0] = _Dt * _Vel[i][1][0];
        _Dis[i][1][1] = _Dt * _Vel[i][1][1];
    }
}

void CartRing::NewmarkReso () {

	//Update boundary spring locations to be used for ->stress->sprVecPred and -sprVecPred, if necessary
	exchangeBoundaryNodes();

    // Build the spring force vector, and spring energy values
    _Wspr = 0.0;
    _WsprD = 0.0;
    for ( unsigned i = _begin; i <= _end; i++ ) {
        _Wspr += sprForc( i );
    }

	//Update spring forces on boundary nodes
	exchangeSprForc();

	if (_allowPlateauEnd) {		//if an early program termination due to a plateauing of cohesive energy is allowed
		if(_myid == 0) {	
			//Update and store plateau-locating data
			if (_Nt % 100 == 0) {		//discrete/martin's method of plateau location; every 100
				_Wcoh100[0] = _Wcoh[0];
			}
			_dWcoh[2] =  _dWcoh[0];		//continuous/andy's method of plateau location; every 1
			_dWcoh[1] = _Wcoh[0];
		}
		MPI::COMM_WORLD.Barrier();
		MPI::COMM_WORLD.Bcast( &_Wcoh100[0], 1, MPI::INT, 0);
		MPI::COMM_WORLD.Bcast( &_dWcoh[1], 2, MPI::INT, 0);
	}

    // Build the cohesive force vector, and cohesive-link energy values
    _Wcoh[0] = 0.0;
    _Wcoh[1] = 0.0;

	//if defectRange exists, must update sequentially to be consistent with serial case (assume this is necessary)
	if (_defectRange > 0) {		//if there is a zone around each fracture site that prevents other nodes from opening, non-zero
		for (unsigned j = 0; j < _numprocs; ++j) {
			int size;
			int begin;
			if (j == _myid) {
				size = _end - _begin + 1;
				begin = _begin;
				for ( unsigned i = _begin; i <= _end; i++ ) {
					std::vector<double> wCoh = cohForc( i );
					_Wcoh[0] += wCoh[0];
					_Wcoh[1] += wCoh[1];
				}
			}

			std::vector<int> local_ActivCoh = _ActivCoh;
			MPI::COMM_WORLD.Allreduce( &_ActivCoh[0], &local_ActivCoh[0], _Nx, MPI::INT, MPI_SUM);
			MPI::COMM_WORLD.Barrier();
		}
	} else {
		for ( unsigned i = _begin; i <= _end; i++ ) {
			std::vector<double> wCoh = cohForc( i );
			_Wcoh[0] += wCoh[0];
			_Wcoh[1] += wCoh[1];
		}

		std::vector<int> local_ActivCoh = _ActivCoh;
		MPI::COMM_WORLD.Allreduce( &_ActivCoh[0], &local_ActivCoh[0], _Nx, MPI::INT, MPI_SUM);
		MPI::COMM_WORLD.Barrier();
	}

	vector<double> wcohlocal(2);
	MPI::COMM_WORLD.Allreduce ( &_Wcoh[0], &wcohlocal[0], 2, MPI::DOUBLE, MPI_SUM);
	_Wcoh[0] = wcohlocal[0]; _Wcoh[1] = wcohlocal[1];

    //Calculate moving averages for plateau location, continuously
	if (_allowPlateauEnd) {
		if(_myid == 0) {	
			double ratio = 0.9995;
			_dWcoh[0] = _dWcoh[0] * ratio + (1 - ratio) * (_Wcoh[0] - _dWcoh[1]) / _Dt;	//new ema of deriv value
			_dWcoh[3] = (_dWcoh[0] - _dWcoh[2]) / _Dt;					//derive of ema ... value
			if ((_dWcoh[4] == 0.0) && (_dWcoh[3] < 0)) {
				_dWcoh[4] = _T;					//set time deriv if ema goes negative
			} else if ((_dWcoh[4] != 0.0) && (_dWcoh[3] > 0)) {
				_dWcoh[4] = 0.0; 				//reset time if deriv of ema goes positive
			} else if ((_dWcoh[4] != 0.0) && (_T > 2.0 * _dWcoh[4])) {
				FILE * pFile;
				pFile = fopen ( _logPath.c_str(), "a" );
				fprintf( pFile, "####    t = %12.3e  - Plastic Cohesive Energy has plateaued, no further fragmentation expected\n", _T );
				fclose( pFile );
				std::cout << "-------------------------------------------------------" << std::endl;
				std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
				std::cout << "t = " << _T << "  - Plastic Cohesive Energy has plateaued, no further fragmentation expected" << std::endl;
				std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
				std::cout << "-------------------------------------------------------" << std::endl;
				_stopFlag = true; 				//stop based on d(EMA(d(Wcoh))), after 2x
			}

			//Calculate moving averages for plateau location, discretely	
			//AJS 2/12/2013 -- NOTE!: This only calculates every 100 time-steps,
			//	so for smaller problems, _Wcoh100[2] is never updated, the column
			//	of data is all zero and gnuplot won't plot it!

			if (_Nt % 100 == 0) {
				double old = _Wcoh100[2];
				_Wcoh100[2] = _Wcoh100[2] * 0.9 + 0.1 * (_Wcoh[0] - _Wcoh100[0])/(_T - _Wcoh100[1]); //new ema value 
				_Wcoh100[1] = _T;
				if ((_Wcoh100[2] - old < 0) && (_Wcoh100[3] == 0)) {
					_Wcoh100[3] = _T;				//set time deriv if ema goes negative
				} else if ((_Wcoh100[3] != 0.0) && (_Wcoh100[2] - old > 0)) {
					_Wcoh100[3] = 0.0;				//reset time if deriv of ema goes positive
			 	} else if ((_dWcoh[4] != 0.0) && (_T > 3.0 * _dWcoh[4])) {
				   // _stopFlag = true;			//stop based on d(EMA(tangents(Wcoh))),after 3x
				}
			}
		}

		MPI::COMM_WORLD.Bcast( &_stopFlag, 1, MPI::BOOL, 0);
	}

    //Adjust for boundary conditions --calculate _VelForcReq
    for ( unsigned i = 0; i < _NodPos.size(); i++) {
			if (!_local[i]) continue;
		    boundaryConditions(i);
    }


    // Build the external force vector, energy & Solve the system

    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
		if (!_local[i]) continue;

        // Compute the external energy
        _Wext += extForc( i );

        // Solve the problem
        _Acc[i][1][0] = ( _Fext[i][1][0] + _Fspr[i][0] + _Fcoh[i][0] ) / _m;
        _Acc[i][1][1] = ( _Fext[i][1][1] + _Fspr[i][1] + _Fcoh[i][1] ) / _m;
    }
}

void CartRing::NewmarkCorr () {

    //Compute kinetic energy
    _Wkin = 0.0;
    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
		if (!_local[i]) continue;

        // Update velocities
        _Vel[i][2][0] = _Vel[i][1][0] + 0.5 * _Dt * _Acc[i][1][0];
        _Vel[i][2][1] = _Vel[i][1][1] + 0.5 * _Dt * _Acc[i][1][1];

        // Compute the kinematic energy
//        _Wkin += 0.5 * _m * ( pow( _Vel[i][2][0], 2 ) + pow( _Vel[i][2][1], 2 ) ); //note - this is changed from v[i][2][0]
        _Wkin += 0.5 * _m * ( pow( _Vel[i][1][0], 2 ) + pow( _Vel[i][1][1], 2 ) ); //note - this is changed from v[i][2][0]
 
        // Displacements
        _Dis[i][2][0] = _Dis[i][1][0];
        _Dis[i][2][1] = _Dis[i][1][1];
    }

}

double CartRing::sprForc ( const unsigned sprNum ) {

    // Compute the stress
    _Stress[sprNum] = stress( sprNum );

    // Compute the axial force in the truss in the corotational frame
    double axiForc = _A * _Stress[sprNum];

    // Compute the spring element vector
    std::vector<double> elmVec = sprVecPred ( sprNum );
    double elmLength = sqrt( pow( elmVec[0], 2 ) + pow( elmVec[1], 2 ) );

    // Compute the nodal internal force in the cartesian frame
    _Fspr[_SprCon[sprNum].first ][0] =        axiForc * elmVec[0] / elmLength;
    _Fspr[_SprCon[sprNum].first ][1] =        axiForc * elmVec[1] / elmLength;
    _Fspr[_SprCon[sprNum].second][0] = -1.0 * axiForc * elmVec[0] / elmLength;
    _Fspr[_SprCon[sprNum].second][1] = -1.0 * axiForc * elmVec[1] / elmLength;
    // Compute the element strain
    double strain = ( pow( elmLength, 2 ) - pow( _Dx, 2 ) )
                  / ( _Dx * ( elmLength + _Dx ) );

    //Compute the average of the strengths of the surrounding cohesive links
	//for use as spring "yield strength" value
    double sigY = 0.0;
    if (sprNum == 0)             sigY = _SigC[sprNum];
    else if (sprNum == _Nx-1)    sigY = _SigC[sprNum-1];
    else                        sigY = 0.5 * _SigC[sprNum] + 0.5 * _SigC[sprNum-1];

    //Compute dissipated spring energy
    _WsprD += 0.5 * _A * _Dx * pow( sigY, 2 ) / _E * ( _sprDamage[sprNum] / (1 - _sprDamage[sprNum] ) );

    //Return elastic spring energy
    return  0.5 * _A * _Dx * strain * _Stress[sprNum];
}

std::vector<double> CartRing::cohForc ( const unsigned cohNum ) {
    // Find out the nodes connected to cohNum link
    int nod_1 = _CohCon[cohNum].first;
    unsigned nod_2 = _CohCon[cohNum].second;

	//ensure that these are owned by the this processor
	//assert(_local[nod_1] || nod_1 == -1); assert(_local[nod_2]);

	//ensure that these are owned by the same processor
	assert(_owner[nod_1] == _owner[nod_2] || nod_1 == -1);

    //Create and assign variable that indicates if this link is open or closed
	//false = closed, true = open
    if (nod_1 != -1) {
        bool cohMod = ( _ActivCoh.size() == _CohCon.size() )
                    ? _ActivCoh[cohNum] : false;

        std::vector<double> wCoh(2);
        // Compute the cohesive force
        if ( cohMod == false ) {
            	//If closed...
            	//cohesive force is an average of spring forces of surrounding elements
            _Fcoh[nod_1][0] = -0.5 * ( _Fspr[nod_1][0] - _Fspr[nod_2][0] );
            _Fcoh[nod_1][1] = -0.5 * ( _Fspr[nod_1][1] - _Fspr[nod_2][1] );
            _Fcoh[nod_2][0] = -0.5 * ( _Fspr[nod_2][0] - _Fspr[nod_1][0] );
            _Fcoh[nod_2][1] = -0.5 * ( _Fspr[nod_2][1] - _Fspr[nod_1][1] );
    
            // Test the value of the cohesive stress
            if ( _SigC.size() == _Nx ) {
                _sigCoh[cohNum] = 0;
                _sigCoh[cohNum] = _Fcoh[nod_1][0] / _A;
    			    //Detect if this cohesive link is within the restricted zone of another,
        			//already open link
        			bool defectRangeFlag = false;	//Assume it is not
        			if (_defectRange > 0) {
        				//Convert the range into number of links
        				int d_num = (int)floor( _defectRange * (double)(_Nx) / _L) ;
	        	      	for (int i = -d_num; i <= d_num; i++) {
	        				//Create link number that is checked against
	        	            unsigned j = ( i + (int)(cohNum) + _Nx) % _Nx;
	        				if (_ActivCoh[j] == true) { 
	        					defectRangeFlag = true;		//true if link is open
	        				}

	        		    }
	        		}
	        		//Allow link to open if all other links in range are closed, & stress>strength
	        	    if ( ( _sigCoh[cohNum] > _SigC[cohNum] ) && (defectRangeFlag == false) ) {
	            	    	_ActivCoh[cohNum] = true;
	        			//Limit stress to maximum value(strength) for this one time-step
	        	        _Fcoh[nod_1][0] = -1.0 * _A * _SigC[cohNum];
	        	        _Fcoh[nod_1][1] = _A * _SigC[cohNum] * 0.0;
	        	        _Fcoh[nod_2][0] = _A * _SigC[cohNum] * 1.0;
	        	        _Fcoh[nod_2][1] = -1.0 * _A * _SigC[cohNum] * 0.0;

/*
            			if (_lawTyp.compare( 0 , 3, "LIN" ) == 0 ) { 
                        double gc = _SigC[cohNum] * _DelC[cohNum] * 0.5;
                        _Wext += _A * _SigC[cohNum] * _SigC[cohNum] / (2*_E + _SigC[cohNum] * _SigC[cohNum]/gc);
            			} else if (_lawTyp.compare( 0 , 4, "SQRT" ) == 0 ) {
                        double gc = _SigC[cohNum] * _DelC[cohNum]/3;
                        double d_inter = _SigC[cohNum] / (_E +  _SigC[cohNum]*_SigC[cohNum]/(2*gc));
                        for (unsigned j = 0; j < 20; ++j) {
                            d_inter = _Dx/_E * _SigC[cohNum]*(1-sqrt(d_inter/_DelC[cohNum]));
                        }
                        _Wext += _A * _SigC[cohNum]* d_inter * (0.5-1.0/6.0*sqrt(d_inter /_DelC[cohNum]));
			        } else {
			            	cout << "cohesive law " << _lawTyp << " not yet implemented!" << endl;
			            	assert(1==0);
            			}*/

	        	    }
            }

        } else {
	    //If open...
            // Compute crack opening distance
            std::vector<double> crack = cohVecPred( cohNum );

	        //Assign delta as the cross-product of the crack location vector 
	        	//and the crack opening (cohesive link) vector; delta in theta-dir only
	        //_delta[cohNum] = 0;
           // _delta[cohNum] = sqrt( pow( crack[0], 2 ) + pow( crack[1], 2 ) );
	        _delta[cohNum] = crack[0];	

	        //Assign damage as ratio of delta to maximum separation
	        //Store _D[][] as the maxiumum damage
            double dammage = _delta[cohNum] / _DelC[cohNum];
            if ( dammage > 1.0 || _D[cohNum][0] >= 1 ) {
                _D[cohNum][1] = 1.0;
            } else {
                _D[cohNum][1] = ( dammage > _D[cohNum][0] ) ? dammage : _D[cohNum][0];
            }
	
            // Compute the cohesive traction
	        _sigCoh[cohNum] = 0;
            cohStr( cohNum ); //assign _sigCoh

            // Compute the cohesive force and apply in the theta direction
            _Fcoh[nod_1][0] = _A * _sigCoh[cohNum] * 1.0;
            _Fcoh[nod_1][1] = _A * _sigCoh[cohNum] * 0.0;
            _Fcoh[nod_2][0] = -1.0 * _A * _sigCoh[cohNum] * 1.0;
            _Fcoh[nod_2][1] = -1.0 * _A * _sigCoh[cohNum] * 0.0;

            // Compute cohesive energy
            wCoh[1] = 0.5 * _A * _sigCoh[cohNum] * _delta[cohNum];
	        	if (_lawTyp.compare( 0 , 3, "LIN" ) == 0 ) { 
           		wCoh[0] = 0.5 * _A * _SigC[cohNum] * _D[cohNum][1] * _DelC[cohNum];
	        	}
	        	else if (_lawTyp.compare( 0 , 4, "SQRT" ) == 0 ) {
	            wCoh[0] = _A * _SigC[cohNum] * _D[cohNum][1] * _DelC[cohNum] * (0.5 - 1.0/6.0 * sqrt(_D[cohNum][1]));
	        	}
	        	else {
	        		cout << "cohesive law " << _lawTyp << " not yet implemented!" << endl;
	        	}

        }
        return wCoh;
    } else { //nod1 = -1***********
        bool cohMod = ( _ActivCoh.size() == _CohCon.size() )
                    ? _ActivCoh[cohNum] : false;

        std::vector<double> wCoh(2);
        // Compute the cohesive force
        if ( cohMod == false ) {
            	//If closed...
            	//cohesive force is an average of spring forces of surrounding elements
            _Fcoh[nod_2][0] = -1.0 * ( _Fspr[nod_2][0] );
            _Fcoh[nod_2][1] = -1.0 * ( _Fspr[nod_2][1] );
    
            // Test the value of the cohesive stress
            if ( _SigC.size() == _Nx ) {
                _sigCoh[cohNum] = 0;
                _sigCoh[cohNum] = -_Fcoh[nod_2][0] / _A;
    			    //Detect if this cohesive link is within the restricted zone of another,
        			//already open link
        			bool defectRangeFlag = false;	//Assume it is not
        			if (_defectRange > 0) {
        				//Convert the range into number of links
        				int d_num = (int)floor( _defectRange * (double)(_Nx) / _L) ;
	        	      	for (int i = -d_num; i <= d_num; i++) {
	        				//Create link number that is checked against
	        	            unsigned j = ( i + (int)(cohNum) + _Nx) % _Nx;
	        				if (_ActivCoh[j] == true) { 
	        					defectRangeFlag = true;		//true if link is open
	        				}

	        		    }
	        		}
	        		//Allow link to open if all other links in range are closed, & stress>strength
	        	    if ( ( _sigCoh[cohNum] > _SigC[cohNum] ) && (defectRangeFlag == false) ) {
	            	    	_ActivCoh[cohNum] = true;
	        			//Limit stress to maximum value(strength) for this one time-step
	        	        _Fcoh[nod_2][0] = _A * _SigC[cohNum] * 1.0;
	        	        _Fcoh[nod_2][1] = -1.0 * _A * _SigC[cohNum] * 0.0;
/*
            			if (_lawTyp.compare( 0 , 3, "LIN" ) == 0 ) { 
                        double gc = _SigC[cohNum] * _DelC[cohNum] * 0.5;
                        _Wext += _A * _SigC[cohNum] * _SigC[cohNum] / (2*_E + _SigC[cohNum] * _SigC[cohNum]/gc);
            			} else if (_lawTyp.compare( 0 , 4, "SQRT" ) == 0 ) {
                        double gc = _SigC[cohNum] * _DelC[cohNum]/3;
                        double d_inter = _SigC[cohNum] / (_E +  _SigC[cohNum]*_SigC[cohNum]/(2*gc));
                        for (unsigned j = 0; j < 20; ++j) {
                            d_inter = _Dx/_E * _SigC[cohNum]*(1-sqrt(d_inter/_DelC[cohNum]));
                        }
                        _Wext += _A * _SigC[cohNum]* d_inter * (0.5-1.0/6.0*sqrt(d_inter /_DelC[cohNum]));
			        } else {
			            	cout << "cohesive law " << _lawTyp << " not yet implemented!" << endl;
			            	assert(1==0);
            			}*/
	        	    }
            }

        } else {
	    //If open...
            // Compute crack opening distance
            std::vector<double> crack = cohVecPred( cohNum );

	        //Assign delta as the cross-product of the crack location vector 
	        	//and the crack opening (cohesive link) vector; delta in theta-dir only
	        //_delta[cohNum] = 0;
           // _delta[cohNum] = sqrt( pow( crack[0], 2 ) + pow( crack[1], 2 ) );
	        _delta[cohNum] = crack[0];	

	        //Assign damage as ratio of delta to maximum separation
	        //Store _D[][] as the maxiumum damage
            double dammage = _delta[cohNum] / _DelC[cohNum];
            if ( dammage > 1.0 || _D[cohNum][0] >= 1 ) {
                _D[cohNum][1] = 1.0;
            } else {
                _D[cohNum][1] = ( dammage > _D[cohNum][0] ) ? dammage : _D[cohNum][0];
            }
	
            // Compute the cohesive traction
	        _sigCoh[cohNum] = 0;
            cohStr( cohNum ); //assign _sigCoh

            // Compute the cohesive force and apply in the theta direction
            _Fcoh[nod_2][0] = -1.0 * _A * _sigCoh[cohNum] * 1.0;
            _Fcoh[nod_2][1] = -1.0 * _A * _sigCoh[cohNum] * 0.0;

            // Compute cohesive energy
            wCoh[1] = 0.5 * _A * _sigCoh[cohNum] * _delta[cohNum];
	        	if (_lawTyp.compare( 0 , 3, "LIN" ) == 0 ) { 
           		wCoh[0] = 0.5 * _A * _SigC[cohNum] * _D[cohNum][1] * _DelC[cohNum];
	        	}
	        	else if (_lawTyp.compare( 0 , 4, "SQRT" ) == 0 ) {
	            wCoh[0] = _A * _SigC[cohNum] * _D[cohNum][1] * _DelC[cohNum] * (0.5 - 1.0/6.0 * sqrt(_D[cohNum][1]));
	        	}
	        	else {
	        		cout << "cohesive law " << _lawTyp << " not yet implemented!" << endl;
	        	}

        }
        return wCoh;


    }


}

void CartRing::boundaryConditions ( const unsigned i ) {

	assert(_local[i]);

    //Calculate force at nodes required to maintain constant strain rate
    //0 for applied constant strain rate, 1 for applied force on end, 2 for applied constant velocity on end
    double type = _ValVelBC[0]; 		
    double target = _ValVelBC[1];

    //Mechanism for disabling loading ONLY at locations with full fragments (DISABLED)
    bool ok = true;	//assume loading ok
    for (unsigned j = 0; j < _fragLoc.size(); j++) {
	if (_fragLoc[j] == (int)i) {
	    ok = false;	//disable if fragment at this link
	}
    }

	bool flag = static_cast<bool>(std::accumulate(_ActivCoh.begin(),_ActivCoh.end(),0));

    if (type == 3) {
        if (flag == false) {
            type = 0;
        } else {
            type = 2;
            target = target * _L; //strainrate target -> velocity target
        }
    }

    //If loading is acceptable...calculate it
    if ( flag == false || type != 0) {			//Any damage cancels all loading for constant strain rate case
        if (type == 0) {
            //applied constant strain rate
    	        _VelForcReq[i][0] = 0.0;
            _VelForcReq[i][1] = 0.0;

            unsigned other = i;
            double sign = 1;
            if (i % 2 == 0) {
                //this is left node of element
                other++;
                sign = 1;
            } else { 
                //this is right node of element
                other--;
                sign = -1;
            }

            double thisVel = 0.5 * (_Vel[i][0][0] + _Vel[i][1][0]); //use average of past and current
            double otherVel = 0.5 * (_Vel[other][0][0] + _Vel[other][1][0]);
            double elmVel = sign*otherVel - sign*thisVel; //differential velocity of whole element (dv)
            double strainRate = elmVel / _Dx;

            double diff = target - strainRate;
		
	       //Calculate required additional force to get to target F = ma = m*dv/dt
    	        _VelForcReq[i][0] = -sign * (diff / _Dt) * _Dx * _m * 0.5 - _Fspr[i][0] - _Fcoh[i][0];
            _VelForcReq[i][1] = 0.0;

        } else if (type == 1) {
            //applied force on end
            _VelForcReq[i][0] = 0.0;
            _VelForcReq[i][1] = 0.0;

            if (i == 2 * _Nx - 1) _VelForcReq[i][0] = target;

        } else if (type == 2) {
            //applied constant velocity on end
            _VelForcReq[i][0] = 0.0;
            _VelForcReq[i][1] = 0.0;

            if (i == 2 * _Nx - 1) {
                double thisVel = 0.5 * (_Vel[i][0][0] + _Vel[i][1][0]); //use average of past and current
                double diff = target - thisVel;
                _VelForcReq[i][0] = (diff / _Dt) * _m - _Fspr[i][0] - _Fcoh[i][0];
            }
            /*
        } else if (type == 3) {
            //applied constant strain rate
    	        _VelForcReq[i][0] = 0.0;
            _VelForcReq[i][1] = 0.0;

            if (i == 2 * _Nx - 1) {
                double thisVel = 0.5 * (_Vel[i][0][0] + _Vel[i][1][0]); //use average of past and current
                double strainRate = thisVel / _L;
                double diff = target - strainRate;
		
        	       //Calculate required additional force to get to target F = ma = m*dv/dt
        	        _VelForcReq[i][0] = (diff / _Dt) * _Dx * _m * 0.5;
            }
    */
        } else {
		    std::cout << "Boundary condition unknown!" << std::endl; 
        }
    } else {
        	_VelForcReq[i][0] = 0;		//...else make sure it's zero
        _VelForcReq[i][1] = 0;
    }
}

double CartRing::extForc ( const unsigned nodNum ) {
	assert(_local[nodNum]);

    //reset values to zero
    _Fext[nodNum][1][0] = 0;
    _Fext[nodNum][1][1] = 0; 

	//Apply calculated correction loading from calcVelForc/boundaryConditions
	_Fext[nodNum][1][0] += _VelForcReq[nodNum][0];
    _Fext[nodNum][1][1] += _VelForcReq[nodNum][1];
	//Reset to zero
	_VelForcReq[nodNum][0] = 0;
	_VelForcReq[nodNum][1] = 0;

    // Compute contribution to external energy of the node
    double wExt = _Vel[nodNum][1][0] * ( _Fext[nodNum][1][0] + _Fext[nodNum][0][0] )	//W = F*d = F*v*dt
                + _Vel[nodNum][1][1] * ( _Fext[nodNum][1][1] + _Fext[nodNum][0][1] );	//  = 0.5*(F1+F2)*v*dt
    return 0.5 * _Dt * wExt;
}

double CartRing::stress ( const unsigned sprNum ) {
    //Determine element stress
    // Compute a prediction of the element position vector
    std::vector<double> elmVec = sprVecPred( sprNum );

    // Compute the truss element / the spring current length
    double curLength = sqrt( pow( elmVec[0], 2 ) + pow( elmVec[1], 2 ) );

    // Compute the Crisfield version of the element strain - equivalent to engineering strain
    double strain = ( pow( curLength, 2 ) - pow( _Dx, 2 ) )
                  / ( _Dx * ( curLength + _Dx ) );

    //Compute Elastic Stress
    double Stress = _E * strain;

    //Allow decreased stiffness in zones where link opening is prohibited
    // Check to see if this element's links are in the range prohibited from opening
    if (_defectRange > 0) {
		bool defectRangeFlag = false;	//for one cohesive link
		bool defectRangeFlag2 = false;	//for the other
        int d_num = (int)floor( _defectRange * (double)(_Nx) / _L) ;	//convert the range to # of links
        for (int i = -d_num; i <= d_num; i++) {
            unsigned j = ( i + (int)(sprNum) + _Nx) % _Nx;	//center the range at this element and check
			if (_ActivCoh[j] == true) { 
				defectRangeFlag = true;		//true if any links within range are open
			}
			unsigned k = ( i + (int)(sprNum-1) + _Nx) % _Nx;
			if (_ActivCoh[k] == true) { 
				defectRangeFlag2 = true;		//true if any links within range are open
	    	}
		}
	
		//Non-hardening (elasto-perfectly-plastic) damage model; if both links are forced shut
		if ((defectRangeFlag == true) && (defectRangeFlag2 == true) && (strain > 0)) {
	
			//Determine average strength value of cohesive links ->yield strength of element
            double sigY = 0.0;
            if (sprNum == 0)             sigY = _SigC[sprNum];
            else if (sprNum == _Nx-1)    sigY = _SigC[sprNum-1];
            else                        sigY = 0.5 * _SigC[sprNum] + 0.5 * _SigC[sprNum-1];
	
			if (_sprDamage[sprNum] == 0.0) {
				//No previous damage
				if (strain <= sigY/_E) {
					//Unloading/reloading along E line (elastic)
					Stress = _E * strain;
					_sprDamage[sprNum] = 0;
				} else {
					//Along sigmaC line, updating damage (damaged)
					Stress = sigY;			//maximum stress allowed
					double E_Hat = sigY / strain;	//tangent line to new point
					_sprDamage[sprNum] = 1.0 - (E_Hat / _E);	//calculate damage
				}
			} else {
				//Previously damaged
				double strainD = sigY / (_E * (1 - _sprDamage[sprNum])); // max strain ever experienced
				if (strain <= strainD) {
					//Unloading/reloading along E_Hat line, no additional damage
					Stress = strain * _E * (1 - _sprDamage[sprNum]);
				} else {
					//Along sigmaC line, further damage
					Stress = sigY;
					double E_Hat = sigY / strain;
					_sprDamage[sprNum] = 1.0 - (E_Hat / _E);
				}
			}
		}
    }

    return Stress;
}

void CartRing::cohStr ( const unsigned cohNum ) {
	//this method contains the formula for the downward-sloping, linear cohesive zone law / traction-separation law
	//this method contains the formula for the square-root curve cohesive zone law / traction-separation law - Nicholas Moes TLS-based

    //Reset cohesive stress to zero
    _sigCoh[cohNum] = 0;
    if ( _delta[cohNum] > 0.0 ) {
        // Tensile behavior
        if ( (_delta[cohNum] > _DelC[cohNum]) || (_D[cohNum][0] >= 1.0 ) ) {
            // Fully broken link
            _sigCoh[cohNum] = 0.0;
        } else {
            // Partially damaged link

			if (_lawTyp.compare( 0 , 3, "LIN" ) == 0 ) { 
            		_sigCoh[cohNum] = _SigC[cohNum] * ( 1.0 - _D[cohNum][1] );
			}
			else if (_lawTyp.compare( 0 , 4, "SQRT" ) == 0 ) {
            		_sigCoh[cohNum] = _SigC[cohNum] * ( 1.0 - sqrt(_D[cohNum][1]) );
			}
			else {
				cout << "cohesive law " << _lawTyp << " not yet implemented!" << endl;
				assert(1==0);
			}

			if ( _delta[cohNum] < _D[cohNum][1] * _DelC[cohNum]) {
	            // Elastic unloading/reloading, no further damage
				_sigCoh[cohNum] *= _delta[cohNum] /( _D[cohNum][1] * _DelC[cohNum]);
			}

        }
    } else {
        // Compressive behavior ( Penalty )
        double pen = 1.0e+0;
		_sigCoh[cohNum] = _delta[cohNum] * _E / _Dx * pen;	//Follow scaled elastic modulus line*pen
    }

	return;
}

void CartRing::energBalance () {

	_WextT = 0;
	MPI::COMM_WORLD.Barrier(); 
	COMM_WORLD.Allreduce ( &_Wext, &_WextT, 1, MPI::DOUBLE, MPI_SUM);
	COMM_WORLD.Allreduce ( &_Wspr, &_Wspr, 1, MPI::DOUBLE, MPI_SUM);
	COMM_WORLD.Allreduce ( &_WsprD, &_WsprD, 1, MPI::DOUBLE, MPI_SUM);
	COMM_WORLD.Allreduce ( &_Wkin, &_Wkin, 1, MPI::DOUBLE, MPI_SUM);
	MPI::COMM_WORLD.Barrier();

	//Sum internal energies
	double Wint = _Wspr + _Wcoh[0] + _Wcoh[1] + _WsprD;
		
	//Determine maximum energy component
	_Wmax = ( Wint > _Wkin ) ? Wint : _Wkin;
	_Wmax = ( _Wmax > _WextT ) ? _Wmax : _WextT;

	//Sum total energies
	_Wsum = fabs(_Wkin + Wint - _WextT);
	
	if (_myid == 0) {
		//Check to see if too much energy is generated - NOTIFICATION @ 1%
		if ( _Wsum > 0.01 * _Wmax) {
		std::cout << "t = " << _T << "  - Energy Balance Violation: " << _Wsum << " > " << _Wmax * 0.01 << std::endl;
		FILE * pFile;
			pFile = fopen ( _logPath.c_str(), "a" );
			fprintf( pFile, "##    t = %12.3e  - Energy Balance Violation: %12.3e > %12.3e\n", _T, _Wsum, _Wmax * 0.01 );
			fclose( pFile );
		}
	}
	
	if (_checkEnergy) {
		//Check to see if too much energy is generated - CUT OFF @ 5%
		if (_Wsum > 0.05 * _Wmax) {
			if (_myid == 0) {
				FILE * pFile;
				pFile = fopen ( _logPath.c_str(), "a" );
				fprintf( pFile, "####    t = %12.3e  - Energy Generation Limit Exceeded (5%% Max) \n", _T );
				fclose( pFile );
				std::cout << "-------------------------------------------------------" << std::endl;
				std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
				std::cout << "t = " << _T << "  - Energy Generation Limit Exceeded (5% Max): " << _Wsum << " > " 
					<< _Wmax * 0.05 <<std::endl;
				std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
				std::cout << "-------------------------------------------------------" << std::endl;
			}
			_stopFlag = true;	//Politely terminates the program at the end of this solve loop
		}

		MPI::COMM_WORLD.Bcast( &_stopFlag, 1, MPI::BOOL, 0);
    	}
}

void CartRing::checkStable () {

    //Check to see if any cohesive link is in compression
    unsigned compression = 0;
    for (unsigned i = _begin; i <= _end; i++) {  
        	if (_sigCoh[i] < 0 ) {
	        compression = 1;
	        _tFlag[1] = 1;	//enable one level of time-step refinement
        	}
    }

    //Check to see if any link > 95% critical stress, or is within critical damage range
    //	meaning that its past the 95% mark and left of the scaled elastic modulus line
    unsigned temp = 0;
    for (unsigned i = _begin; i <= _end; i++ ){
	 	if ( ( (_delta[i] > 0 ) && ( _D[i][1] < (_sigCoh[i]) / (_E/_Dx) )) || _sigCoh[i] > 0.95 * _SigC[i]) {
			temp += 1; 		//count the number of links in this critical region
		}
    }
    
    //Activate an additional level of time-step refinement if any link is in critical zone
    if (temp == 0) {
		_tFlag[1] += 0;		//Keep level as is
    } else {
		_tFlag[1] += 1;		//Add one
    }
	
	unsigned valIn = _tFlag[1];
	unsigned valOut = 0;
	MPI::COMM_WORLD.Barrier(); COMM_WORLD.Allreduce ( &valIn, &valOut, 1, MPI::INT, MPI_MAX);
	_tFlag[1] = valOut;

}

void CartRing::fragCount () {

    //Count the number of broken cohesive links
    _fragLoc.resize(0);
    _numFrag = 0;
    _DSum = 0;

    for (unsigned i = _begin; i <= _end; i++ ){
		//Sum the total amount of damage to all links (analogous to WcohD)
		_DSum += (_D[i][1] >= 1) ? 1 : _D[i][1];

		//Check to see if fully broken
		if (_D[i][1] >= 1){
			_numFrag += 1;		//Add to fragment count
			_fragLoc.push_back(i);	//Add location to fragment location list
		}
    }

	exchangeFragInfo();

	if (_myid == 0) {
		//Find the length of each fragment
		if (_numFrag == 0){
			_fragLength.resize(1);
			_fragLength[0] = _Nx * _Dx *2 ;	//if only one break, length is whole circumference of ring
		} else {
			double nElems = 0;
			_fragLength.resize(numFragSymm());
			for (unsigned k = 0; k < _numFrag; k++){
				if (k == _numFrag - 1){
					//Length (# elems between) from last to end
					nElems = fabs( _fragLoc[k] - static_cast<int>(_Nx));
				} else {
					//Length (# elems between)
					nElems = fabs( _fragLoc[k] - _fragLoc[k + 1]);
				}
				//Convert number of elements to actual length
				_fragLength[2*k] = nElems * _Dx;
				_fragLength[2*k+1] = nElems * _Dx;
			}
            	//Convert number of elements to actual length
            if (_numFrag * 2 != numFragSymm()) //if not broken at 0 - also D[0][1] < 1
		    _fragLength[_numFrag * 2 - 1] = _fragLoc[0] * 2 * _Dx;
            
		}

		//Initialize statistics of fragment length distribution
		_fMean = 0;
		_fMed = 0;
		_fMax = 0;
		_fMin = 0;
		_fStDev = 0;
		_fRange = 0;
		_fSkew = 0;
		_fExKurtosis = 0;

		//If there are any fragments...
		if (_numFrag > 0){
			//Calculate Median
			// Sort the list in ascending order
			sort(_fragLength.begin(), _fragLength.end());

			if (_numFrag % 2 == 0) {
				//If even number, take average of two middle values
				_fMed = ( _fragLength[ (unsigned)(_numFrag * 0.5) ]
					+ _fragLength[ (unsigned)(_numFrag * 0.5) -1 ] ) * 0.5;
			} else {
				//If odd number, take middle value
				_fMed = _fragLength[ (_numFrag - 1) / 2 ];
			}
			//Calculate Max, Min, Range
			_fMax = _fragLength.back();
			_fMin = _fragLength.front();
			_fRange = _fMax - _fMin;
	
			//Calculate Mean
			for (unsigned k = 0; k < _fragLength.size(); k++){
				//Sum of lengths
				_fMean += _fragLength[k];
			}
			//Mean = sum / number
			_fMean = _fMean / _numFrag;

			//Calculate Std. Deviation
			for (unsigned k = 0; k < _fragLength.size(); k++){
				//Sum of squared (lengths - means)
				_fStDev += pow( (_fragLength[k] - _fMean), 2);
			}
			_fStDev = sqrt( _fStDev / _numFrag ) ;

			//Calculate Skew
			for (unsigned k = 0; k < _fragLength.size(); k++){
				//Sum of squared (lengths - means)
				_fSkew += pow( (_fragLength[k] - _fMean), 3);
			}
			_fSkew = _fSkew / (_numFrag * pow(_fStDev,3) );

			//Calculate Kurtosis
			for (unsigned k = 0; k < _fragLength.size(); k++){
				//Sum of squared (lengths - means)
				_fExKurtosis += pow( (_fragLength[k] - _fMean), 4);
			}
			_fExKurtosis = _fExKurtosis / (_numFrag * pow(_fStDev,4) ) - 3.0;

		}
	}
}

void CartRing::timeStepRefine (const double refine) {
	//Initialization
	if (_Nt == 0) {
	    _deactive = 0;	//first-level refinement reduction multiplier
	    _deactive2 = 0;	//second-level refinement reduction multiplier
	}
/*
	//If there is a call for time-step refinement....
	if (_tFlag[1] != 0){	
	    if (_tFlag[0] == 0) {
		//If flag went from nothing to something
		std::cout << "Adaptive time-step initiated. t = " << _T << std::endl;
		_deactive = 0.0;
		_deactive2 = 0.0;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step initiated. t =  %e\n", _T );
    		fclose( pFile );
	    }    
	    if (_tFlag[1] == 2) {
		//If flag went from nothing to second level, second-level refinement
		_Dt = refine * refine * _Dt;
		_deactive = 0.0;
		_deactive2 = 0.0;
		if (_tFlag[0] != 2) {
		    std::cout << "Adaptive time-step refined. t = " << _T << std::endl;
		    FILE * pFile;
    		    pFile = fopen ( _logPath.c_str(), "a" );
    		    fprintf( pFile, "##    Adaptive time-step refined. t =  %e\n", _T );
    		    fclose( pFile );
		}
	    }
	    if ((_tFlag[1] == 1) && (_deactive2 == 0.0) && (_tFlag[0] != 2)) {
	    //If not doing second-level refinement, then do first-level refinement
	 	_Dt = refine * _Dt;
	    }
	}

	if (_tFlag[1] == 0){
	    //If flag went to zero...
	    if (_tFlag[0] == 1) {
		//If flag went from first level to zero
		std::cout << "Adaptive time-step released. t = " << _T << std::endl;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step released %e\n", _T );
    		fclose( pFile );
		//Signal demand to decrease first-level refinement
		_deactive = 1.0;
	    }
	    if (_tFlag[0] == 2) {
		//If flag went from second level to zero
		std::cout << "Adaptive time-step released. t = " << _T << std::endl;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step released. t =  %e\n", _T );
    		fclose( pFile );
		//Signal demand to decrease first-level refinement
		_deactive = 1.0;
		//Signal demand to decrease second-level refinement
		_deactive2 = 1.0;
	    }
	}

	if (_tFlag[1] == 1){
	    if (_tFlag[0] == 2) {	//If flag went from second level to first
		std::cout << "Adaptive time-step loosened. t = " << _T << std::endl;
		_deactive2 = 1.0;	//Signal demand to decrease second-level refinement
		_deactive = 0.0;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step loosened. t =  %e\n", _T );
    		fclose( pFile );
	    }
	}
	
	if (_deactive != 0.0 && _deactive2 == 0.0) {
	    //If doing first-level refinement reduction (1 -> 0)...
	    // Gradually relax the step linearly back to original over 5000 periods
	    _deactive = _deactive - 0.0002;
	    //Apply refinement
	    _Dt = _Dt * (1.0 + (refine - 1.0) * _deactive);
	    if (_deactive <= 0.0) {
		//If 1->0 reduction completed..
		std::cout << "Gradual relaxing 1 --> 0 completed. t = " << _T << std::endl;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Gradual relaxing 1 --> 0 completed. t =  %e\n", _T );
    		fclose( pFile );
		//Reset to zero, as to not trigger this loop again
		_deactive = 0.0;
	    }
	}
	if (_deactive2 != 0.0) {
	    //If doing second-level refinement reduction (2 -> 1)...
	    // Gradually relax the step linearly back to level one over 5000 periods
	    _deactive2 = _deactive2 - 0.0002;
	    //Apply refinement
	    _Dt = _Dt * refine * (1.0 + (refine - 1.0) * _deactive2);
	    if (_deactive2 <= 0.0 && _Nt != 0) {
		//If 2->1 reduction completed
		std::cout << "Gradual relaxing 2 --> 1 completed. t = " << _T << std::endl;
		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Gradual relaxing 2 --> 1 completed. t =  %e\n", _T );
    		fclose( pFile );
		//Reset to zero, as to not trigger this loop again
		_deactive2 = 0.0;
	    }
	}
*/

	if (_myid == 0) {

	double mult = 0.0;
	if (_tFlag[1] == 2 && _tFlag[0] == 2) {
	    _deactive = 0;
	    _deactive2 = 0;
	    mult = refine * refine;
	}
	if (_tFlag[1] == 1 && _tFlag[0] == 2) {
	    _deactive = 0;
	    _deactive2 = 1;
	}
	if (_tFlag[1] == 0 && _tFlag[0] == 2) {
	    _deactive = 1;
	    _deactive2 = 1;
	}
	if (_tFlag[1] == 2 && _tFlag[0] == 1) {
	    _deactive = 0;
	    _deactive2 = 0;
	    mult = refine * refine;
	}
	if (_tFlag[1] == 1 && _tFlag[0] == 1) {
	    _deactive = 0;
	    if (_deactive2 == 0) {
		mult = refine;
	    }
	}
	if (_tFlag[1] == 0 && _tFlag[0] == 1) {
	    _deactive = 1;
	}
	if (_tFlag[1] == 2 && _tFlag[0] == 0) {
	    _deactive = 0;
	    _deactive2 = 0;
	    mult = refine * refine;
	}
	if (_tFlag[1] == 1 && _tFlag[0] == 0) {
	    _deactive = 0;
	    if (_deactive2 == 0) {
		mult = refine;
	    }
	}
	if (_tFlag[1] == 0 && _tFlag[0] == 0) {
	    if (_deactive2 == 0) {
		if (_deactive == 0) {
		    mult = 1.0;
		}
	    } else {
		_deactive = 1.0;
	    }
	}

	if (_tFlag[1] != 0 && _tFlag[0] == 0) {
		std::cout << "Adaptive time-step initiated. t = " << _T << std::endl;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step initiated. t =  %e\n", _T );
    		fclose( pFile );
	}

	if (_tFlag[1] == 2 && _tFlag[0] != 2) {
	    std::cout << "Adaptive time-step refined. t = " << _T << std::endl;
	    FILE * pFile;
    	    pFile = fopen ( _logPath.c_str(), "a" );
    	    fprintf( pFile, "##    Adaptive time-step refined. t =  %e\n", _T );
    	    fclose( pFile );
	}

	if (_tFlag[1] != 2 && _tFlag[0] == 2) {
		std::cout << "Adaptive time-step loosened. t = " << _T << std::endl;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step loosened. t =  %e\n", _T );
    		fclose( pFile );
	}

	if (_tFlag[1] == 0 && _tFlag[0] != 0) {
		std::cout << "Adaptive time-step released. t = " << _T << std::endl;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step released. t =  %e\n", _T );
    		fclose( pFile );
	}

	if (_deactive2 == 0) {
	    if (_deactive == 0) {
		//Mult should be predefined.
	    } else {
			mult = 1 - (1 - refine) * _deactive;
			_deactive = _deactive - 0.0002;
			if (_deactive <= 0.0) {
				_deactive = 0.0;
				std::cout << "Gradual relaxing 1 --> 0 completed. t = " << _T << std::endl;
				FILE * pFile;
				pFile = fopen ( _logPath.c_str(), "a" );
				fprintf( pFile, "##    Gradual relaxing 1 --> 0 completed. t =  %e\n", _T );
				fclose( pFile );
			}
	    }
	} else {
	    mult = refine * (1 - (1 - refine) * _deactive2);
	    _deactive2 = _deactive2 - 0.0002;
	    if (_deactive2 <= 0.0) {
		_deactive2 = 0.0;
		std::cout << "Gradual relaxing 2 --> 1 completed. t = " << _T << std::endl;
		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Gradual relaxing 2 --> 1 completed. t =  %e\n", _T );
    		fclose( pFile );
	    }
	}
	
	if (mult == 0) {
	    std::cout << "Mult should have been defined by now" << std::endl;
	}
	_Dt = mult * _Dt;
	}

	MPI::COMM_WORLD.Bcast( &_Dt, 1, MPI::DOUBLE, 0);
	MPI::COMM_WORLD.Bcast( &_deactive, 1, MPI::DOUBLE, 0);
	MPI::COMM_WORLD.Bcast( &_deactive2, 1, MPI::DOUBLE, 0);

	/*Time Step Refinement Summary:
		CartRing::checkStable() evaluates the current position of all cohesive links
		in the cohesive law diagram. Levels of refinement are warranted for either or
		both of the two following cases: critical zone and compression. Critical zone
		means that one or more cohesive links is on the vertical axis at or above 95%
		of critical stress and left of the elastic modulus line. The elastic modulus
		line is the elastic modulus scaled by element length. When an element is 
		within this critical zone, one level of time step refinement is warranted.
		The second is compression. When any element has a cohesive stress less than
		zero, it is considered to be in compression, and warrants one level of time-
		step refinement. So, if there are compressive elements and critical-zone
		elements, the level of refinement is two. Either alone is one. None is none.

		A zero-level of time step refinement means that _Dt is just 0.8 times the
		critical time-step, _Dt_c. One level of refinement will multiply _Dt times an
		additional factor, 'refine'. When refinement is no longer called for, the
		refinement reduction multiplier of refine, '_deactive', will go linearly from
		one to zero over 5000 periods, linearly bringing the effective multiplier
		from 'refine' to 1. The second level of time-step refinement multiplies _Dt
		by 'refine' squared. Similarly, when only a single level is then required,
		_deactive2 varies from one to zero, bringing the effective multiplier from
		refine^2 to refine over	5000 steps. Going from a second level to zero 
		immediately will run through the _deactive2 sequence (2->1) and then the
		_deactive sequence (1->0) sequentially over a total of 10000 periods. */
}

void CartRing::update () {

    // Nodal positions, Kinematics & External forces 
    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
		if (!_local[i]) continue;
        for ( unsigned j = 0; j < 2; j++ ) {
            // Nodal positions
            _NodPos[i][j] += _Dis[i][2][j];
            // Kinematics
            _Dis[i][0][j]  = _Dis[i][2][j];
            _Vel[i][0][j]  = _Vel[i][2][j];
            _Acc[i][0][j]  = _Acc[i][1][j];
            // External forces
            _Fext[i][0][j] = _Fext[i][1][j];
        }
    }

    // Internal variables
    for ( unsigned i = _begin; i <= _end; i++ ) {
        _D[i][0] = _D[i][1];
    }
}

std::vector<double> CartRing::sprVec ( const unsigned sprNum ) const {

    // Get the connectivity of the element sprNum
    unsigned nod_1 = _SprCon[sprNum].first;
    unsigned nod_2 = _SprCon[sprNum].second;

    //Calculate element length vector
    std::vector<double> elmVec (2);
    elmVec[0] = _NodPos[nod_2][0] - _NodPos[nod_1][0];
    elmVec[1] = _NodPos[nod_2][1] - _NodPos[nod_1][1];

    return elmVec;
}

std::vector<double> CartRing::sprVecPred ( const unsigned sprNum ) const {

    // Get the connectivity of the element sprNum
    unsigned nod_1 = _SprCon[sprNum].first;
    unsigned nod_2 = _SprCon[sprNum].second;

    //Calculate expected element length vector
    std::vector<double> elmVec (2);
    elmVec[0] = ( _NodPos[nod_2][0] + _Dis[nod_2][1][0] ) 
              - ( _NodPos[nod_1][0] + _Dis[nod_1][1][0] );
    elmVec[1] = ( _NodPos[nod_2][1] + _Dis[nod_2][1][1] ) 
              - ( _NodPos[nod_1][1] + _Dis[nod_1][1][1] );

    return elmVec;
}

std::vector<double> CartRing::cohVecPred ( const unsigned cohNum ) const {

    // Get the connectivity of the element cohNum
    int nod_1 = _CohCon[cohNum].first;
    unsigned nod_2 = _CohCon[cohNum].second;

    //Calculate expected link length vector
    std::vector<double> elmVec (2);
    if (nod_1 != -1) {
        elmVec[0] = ( _NodPos[nod_2][0] + _Dis[nod_2][1][0] )
                  - ( _NodPos[nod_1][0] + _Dis[nod_1][1][0] );
        elmVec[1] = ( _NodPos[nod_2][1] + _Dis[nod_2][1][1] )
                  - ( _NodPos[nod_1][1] + _Dis[nod_1][1][1] );
    } else { //nod_1 == -1
        elmVec[0] = ( _NodPos[nod_2][0] + _Dis[nod_2][1][0] );
        elmVec[1] = ( _NodPos[nod_2][1] + _Dis[nod_2][1][1] );
    }
    return elmVec;
}

void CartRing::defineBoundaryNodes() { 
	//create list of node to be sent, origin, and destination
	int size;
	if (_myid == 0) {
		for (unsigned sprNum = 0; sprNum < _Nx; ++sprNum) {
			// Get the connectivity of the element sprNum
			unsigned nod_1 = _SprCon[sprNum].first;
			unsigned nod_2 = _SprCon[sprNum].second;

			int owner1 = _owner[nod_1];
			int owner2 = _owner[nod_2];
	
			if (owner1 != owner2) {
				//cout << "sprVecPred:  " << "(" << sprNum << ") " << nod_1 << " - "  << owner1 << " || " << nod_2 << " - " << owner2 << endl;

				//owner 1 needs to send nod_1 to owner 2; owner 2 needs to send nod_2 to owner 1
				_nodeList.push_back(nod_1); _originList.push_back(owner1); _destList.push_back(owner2); //_dirList.push_back(1);
				//_nodeList.push_back(nod_2); _originList.push_back(owner2); _destList.push_back(owner1); _dirList.push_back(2);
			}
		}
		size = _nodeList.size();
	}

	MPI::COMM_WORLD.Barrier();
	//broadcast sizes and resize vectors
	MPI::COMM_WORLD.Bcast( &size, 1, MPI::INT, 0);
	_nodeList.resize(size); _originList.resize(size); _destList.resize(size);// _dirList.resize(size);		

	//broadcast boundary nodes to be exchanged	
	MPI::COMM_WORLD.Barrier();
	MPI::COMM_WORLD.Bcast( &_nodeList[0], _nodeList.size(), MPI::INT, 0);
	MPI::COMM_WORLD.Bcast( &_originList[0], _nodeList.size(), MPI::INT, 0);
	MPI::COMM_WORLD.Bcast( &_destList[0], _nodeList.size(), MPI::INT, 0);
	//MPI::COMM_WORLD.Bcast( &_dirList[0], _nodeList.size(), MPI::INT, 0);
	MPI::COMM_WORLD.Barrier();
}

void CartRing::exchangeBoundaryNodes () { 
	//use direction one to pull spring nodes in from neighboring elements
	//send all nodes
	for (unsigned i = 0; i < _nodeList.size(); ++i) {
		int tag = i*2;
		if (_myid == _originList[i] /*&& _dirList[i] == 1*/) {
			COMM_WORLD.Send(&_NodPos[_nodeList[i]][0], 2, MPI::DOUBLE, _destList[i], tag);
			COMM_WORLD.Send(&_Dis[_nodeList[i]][1][0], 2, MPI::DOUBLE, _destList[i], tag+1);
			//cout << "disp: sent node " << _nodeList[i] << " from " << _originList[i] << " to " << _destList[i] << endl;
		}
	}

	MPI::COMM_WORLD.Barrier();

	//receive all nodes
	for (unsigned i = 0; i < _nodeList.size(); ++i) {
		int tag = i*2;
		if (_myid == _destList[i] /* && _dirList[i] == 1*/) {
			COMM_WORLD.Recv(&_NodPos[_nodeList[i]][0], 2, MPI::DOUBLE, _originList[i], tag);
			COMM_WORLD.Recv(&_Dis[_nodeList[i]][1][0], 2, MPI::DOUBLE, _originList[i], tag+1);
		}
	}

	MPI::COMM_WORLD.Barrier();

	return;
}

void CartRing::exchangeSprForc () {
	//use direction two to set spring nodes on neighboring elements' spring force	

	//send all nodes -- reverse direction
	for (unsigned i = 0; i < _nodeList.size(); ++i) {
		int tag = i;
		if (_myid == _destList[i] /*&& _dirList[i] == 1*/) {
			COMM_WORLD.Send(&_Fspr[_nodeList[i]][0], 2, MPI::DOUBLE, _originList[i], tag);
			//cout << "force: sent node " << _nodeList[i] << " from " << _destList[i] << " to " << _originList[i] << endl;
		}
	}

	MPI::COMM_WORLD.Barrier();

	//receive all nodes -- reverse direction
	for (unsigned i = 0; i < _nodeList.size(); ++i) {
		int tag = i;
		if (_myid == _originList[i]  /*&& _dirList[i] == 1*/) {
			COMM_WORLD.Recv(&_Fspr[_nodeList[i]][0], 2, MPI::DOUBLE, _destList[i], tag);
		}
	}

	MPI::COMM_WORLD.Barrier();



	return;
}

void CartRing::exchangeFragInfo() {

    int locNumFrag = _fragLoc.size();

    vector<int> numfrags(_numprocs);
    MPI::COMM_WORLD.Allgather(&locNumFrag, 1, MPI::INT, &numfrags[0], 1, MPI::INT);

    _numFrag = 0;
    for (unsigned i=0; i<_numprocs; i++) 
        _numFrag += numfrags[i];

    vector<int> outVector (_numFrag);
    int displ[_numprocs]; 

    if (_myid == 0) {
        double sum = 0;
        for (unsigned i = 0; i < _numprocs; ++i) {
            displ[i] = sum;
            sum += numfrags[i];
        }
    }

    MPI::COMM_WORLD.Gatherv(&_fragLoc[0], numfrags[_myid], MPI::INT, &outVector[0], &numfrags[0], &displ[0], MPI::INT,0);

	MPI::COMM_WORLD.Barrier();
	_fragLoc.resize(0); _fragLoc.resize(_numFrag);

	if (_myid == 0) {
		for (unsigned i = 0; i < _numFrag; ++i) 		_fragLoc[i] = outVector[i];
	}

	MPI::COMM_WORLD.Bcast( &_fragLoc[0], _numFrag, MPI::INT, 0);
	double valIn = _DSum;
	double valOut = 0.0;
	MPI::COMM_WORLD.Allreduce ( &valIn, &valOut, 1, MPI::DOUBLE, MPI_SUM);
	_DSum = valOut;

	return;
}


/*******************************************************************************

                M E T H O D S    T O     P R I N T     S T U F F

*******************************************************************************/

/*------------------------------- P U B L I C --------------------------------*/

void CartRing::plotAtNodes ( const std::vector<unsigned>& NodalIds ) {
	if (_myid == 0) {

		// Gnuplot file for radial velocity 
		FILE * pFileVr;
		std::string velRFile = _path+"/gnuplot/plotRadialVelo.plt";		//../results
		pFileVr = fopen( velRFile.c_str(), "w" );
		fprintf( pFileVr, "#!/usr/bin/gnuplot\n" );
		fprintf( pFileVr, "# GNUPLOT file generated by <cartRing.h>");
		fprintf( pFileVr, " -- MH[DCML] (2010)\n");
		fprintf( pFileVr, "# Radial velocities at prescribed nodes\n" );
		fprintf( pFileVr, "set xlabel \"time (s)\"\n" );
		fprintf( pFileVr, "set ylabel \"radial velocities (m/s)\"\n" );
		fprintf( pFileVr, "set terminal svg size 1200, 800\n\n" );
		fprintf( pFileVr, "set output './pngFiles/nodalRadialVelo.svg'\n");
		fprintf( pFileVr, "plot " );
		fclose( pFileVr );

		// Gnuplot file for circumferential velocity 
		FILE * pFileVt;
		std::string velTFile = _path+"/gnuplot/plotCircumVelo.plt";		//../results
		pFileVt = fopen( velTFile.c_str(), "w" );
		fprintf( pFileVt, "#!/usr/bin/gnuplot\n" );
		fprintf( pFileVt, "# GNUPLOT file generated by <cartRing.h>");
		fprintf( pFileVt, " -- MH[DCML] (2010)\n");
		fprintf( pFileVt, "# Circumferential velocities at prescribed nodes\n" );
		fprintf( pFileVt, "set xlabel \"time (s)\"\n" );
		fprintf( pFileVt, "set ylabel \"circumferential velocities (m/s)\"\n" );
		fprintf( pFileVt, "set terminal svg size 1200, 800\n\n" );
		fprintf( pFileVt, "set output './pngFiles/nodalCircumVelo.svg'\n");
		fprintf( pFileVt, "plot " );
		fclose( pFileVt );

		_NodesToPlot.resize( NodalIds.size() );
		_NodeFiles.resize( NodalIds.size() );
		for ( unsigned i = 0; i < _NodesToPlot.size(); i++ ) {
		    _NodesToPlot[i] = NodalIds[i];
		    std::string nodalId = convertInt( NodalIds[i] );
		    _NodeFiles[i] = _path+"/datFiles/node_" + nodalId + ".dat";	//../results
		    // Prepare Gnuplot data file
		    FILE * pFile;
		    pFile = fopen( _NodeFiles[i].c_str(), "w" );
		    fprintf( pFile, "# GNUPLOT file generated by <cartRing.h>" );
		    fprintf( pFile, " -- MH [DCML] (2010)\n" );
		    fprintf( pFile, "# Nodal quantities for node: %s\n", nodalId.c_str() );
		    fprintf( pFile, "#       time          vr          vt\n" );
		    fclose( pFile );
		    // Complete velocity file
		    std::string nodFil = "./datFiles/node_" + nodalId + ".dat";		//.
		    pFileVr = fopen( velRFile.c_str(), "a" );
		    fprintf( pFileVr, "\"%s\" usi 1:2 ti \"vr_%s\" w l",
		             nodFil.c_str(), nodalId.c_str() );
		    if ( i != _NodesToPlot.size()-1 ) {
		        fprintf( pFileVr, ",\\\n     " );
		    }
		    fclose( pFileVr );
		    pFileVt = fopen( velTFile.c_str(), "a" );
		    fprintf( pFileVt, "     \"%s\" usi 1:3 ti \"vt_%s\" w l ",
		             nodFil.c_str(), nodalId.c_str() );
		    if ( i != _NodesToPlot.size()-1 ) {
		        fprintf( pFileVt, ",\\\n     " );
		    }
		    fclose( pFileVt );
		}
	} else {
		_NodesToPlot.resize( NodalIds.size() );
		_NodeFiles.resize( NodalIds.size() );
		for ( unsigned i = 0; i < _NodesToPlot.size(); i++ ) {
		    _NodesToPlot[i] = NodalIds[i];
		    std::string nodalId = convertInt( NodalIds[i] );
		    _NodeFiles[i] = _path+"/datFiles/node_" + nodalId + ".dat";	//../results
		}
	}
	return;

}

void CartRing::plotAtElms ( const std::vector<unsigned>& ElmIds ) {
	if (_myid == 0) {

		// Gnuplot file for stresses
		FILE * pFileS;
		std::string stressFile = _path+"/gnuplot/plotStre.plt";	//../results
		pFileS = fopen( stressFile.c_str(), "w" );
		fprintf( pFileS, "#!/usr/bin/gnuplot\n" );
		fprintf( pFileS, "# GNUPLOT file generated by <cartRing.h>");
		fprintf( pFileS, " -- MH[DCML] (2010)\n");
		fprintf( pFileS, "# Stresses at prescribed elements\n" );
		fprintf( pFileS, "set xlabel \"time (s)\"\n" );
		fprintf( pFileS, "set ylabel \"stress (Pa)\"\n" );
		fprintf( pFileS, "set terminal svg size 1200, 800\n\n" );
		fprintf( pFileS, "set output './pngFiles/elmStress.svg'\n");
		fprintf( pFileS, "plot " );
		fclose( pFileS );

		_ElmsToPlot.resize( ElmIds.size() );
		_ElmFiles.resize( ElmIds.size() );
		for ( unsigned i = 0; i < _ElmsToPlot.size(); i++ ) {
		    _ElmsToPlot[i] = ElmIds[i];
		    std::string elmId = convertInt( ElmIds[i] );
		    _ElmFiles[i] = _path+"/datFiles/elem_" + elmId + ".dat";	//../results
		    // Prepare Gnuplot data file
		    FILE * pFile;
		    pFile = fopen( _ElmFiles[i].c_str(), "w" );
		    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
		    fprintf( pFile, " -- MH [DCML] (2010)\n" );
		    fprintf( pFile, "# Elm quantities for node: %s\n", elmId.c_str() );
		    fprintf( pFile, "#       time          st\n" );
		    fclose( pFile );
		    // Complete stress file
		    std::string elmFil = "./datFiles/elem_" + elmId + ".dat";		//.
		    pFileS = fopen( stressFile.c_str(), "a" );
		    fprintf( pFileS, "\"%s\" usi 1:2 ti \"st_%s\" w l ",
		             elmFil.c_str(), elmId.c_str() );
		    if ( i != _ElmsToPlot.size()-1 ) {
		        fprintf( pFileS, ",\\\n     " );
		    }
		    fclose( pFileS );
		}
	} else {
		_ElmsToPlot.resize( ElmIds.size() );
		_ElmFiles.resize( ElmIds.size() );
		for ( unsigned i = 0; i < _ElmsToPlot.size(); i++ ) {
		    _ElmsToPlot[i] = ElmIds[i];
		    std::string elmId = convertInt( ElmIds[i] );
		    _ElmFiles[i] = _path+"/datFiles/elem_" + elmId + ".dat";	//../results
		}
	}
}

void CartRing::plotEnergies () {
	if (_myid > 0) return;

    // Gnuplot file for energies
    FILE * pFileW;
    std::string stressFile = _path+"/gnuplot/plotEnrg.plt";		//../results
    pFileW = fopen( stressFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <cartRing.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Global energies\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"energy (J)\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgSpr.svg'\n");
    if (_defectRange == -1.0) {			//not sure why this is here
		fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'Wspr' w l\n" );
    } else {
		fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'WsprE' w l ,\\\n" );
		fprintf( pFileW, "     './datFiles/energies.dat' usi 1:14 ti 'WsprD' w l\n" );
    }
    fprintf( pFileW, "set output './pngFiles/enrgCoh.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:3 ti 'WcoD' w l ,\\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:4 ti 'WcoE' w l\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgExt.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:5 ti 'Wext' w l\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgKin.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:6 ti 'Wkin' w l\n\n" );
    fprintf( pFileW, "set ylabel \"Energy Balance Check\"\n" );
    fprintf( pFileW, "set output './pngFiles/enrgBalance.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:8 ti 'Wsum' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:7 ti '0.01 * Wmax' w l\n\n" );
    fprintf( pFileW, "set ylabel \"J/s\"\n" );

    fprintf( pFileW, "set output './pngFiles/enrgAll.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'Wspr' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:3 ti 'WcoD' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:4 ti 'WcoE' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:5 ti 'Wext' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:6 ti 'Wkin' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:($2+$3+$4+$6) ti 'Wsum' w l\n\n");

    fprintf( pFileW, "set output './pngFiles/enrgdWcoh.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:11 ti 'EMA(dWcoh)' w l\n\n" );
    fprintf( pFileW, "set ylabel \"J/s2\"\n" );
    fprintf( pFileW, "set output './pngFiles/enrgd2Wcoh.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:12 ti 'd(EMA(dWcoh))' w l\n\n" );
    fprintf( pFileW, "set logscale y\n" );
    fprintf( pFileW, "set ylabel \"J/s\"\n" );
    fprintf( pFileW, "set output './pngFiles/enrgdWcoh100.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:13 ti 'dWcoh100' w l\n\n" );

    fclose( pFileW );

    // Prepare Gnuplot data file
    _EnrgFile = _path+"/datFiles/energies.dat";		//../results
    FILE * pFile;
    pFile = fopen( _EnrgFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Total energies for the system\n" );
    fprintf( pFile, "#       time       WsprE       WcohD       WcohE");
    fprintf( pFile, "        Wext        Wkin   0.01*Wmax        Wsum" );
    fprintf( pFile, "       tFlag      refine  EMA(dWcoh) d(EMA(dWcoh" );
    fprintf( pFile, "))  dWcoh100       WsprD\n" );
    fclose( pFile );
}

void CartRing::plotCohLaw (const std::vector<unsigned>& cohNums){

	// Prepare Gnuplot data file
	if (_numprocs == 1) {
		_CohLawFile = _path+"/datFiles/cohLaw.dat";		//../results
	} else {
		_CohLawFile = _path+"/datFiles/cohLaw_" + convertInt(_myid) + ".dat";		//../results
	}	

	if (_myid == 0) {

		_cLaw.resize( cohNums.size() );
		for (unsigned i = 0; i < cohNums.size(); i++){
			_cLaw[i] = cohNums[i];
		}
		// Gnuplot file for cohesive link information
		FILE * pFileW;
		std::string cohFile = _path+"/gnuplot/plotCohLaw.plt";		//../results
		pFileW = fopen( cohFile.c_str(), "w" );
		fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
		fprintf( pFileW, "# GNUPLOT file generated by <cartRing.h>");
		fprintf( pFileW, " -- MH[DCML] (2010)\n");
		fprintf( pFileW, "# Cohesive Law\n" );
		fprintf( pFileW, "set xlabel \"crack opening (m)\"\n" );
		fprintf( pFileW, "set ylabel \"traction (Pa)\"\n" );
		fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );

		for (unsigned i = 0; i < _cLaw.size(); i++) {
			if (_lawTyp.compare( 0 , 3, "LIN" ) == 0 ) { 
            		fprintf( pFileW, "s1(x) = %12.3e * ( 1.0 - x/%12.3e);\n", _SigC[ _cLaw[i] ], _DelC[ _cLaw[i] ] );
			}
			else if (_lawTyp.compare( 0 , 4, "SQRT" ) == 0 ) {
            		fprintf( pFileW, "s1(x) = %12.3e * ( 1.0 - sqrt(x/%12.3e));\n", _SigC[ _cLaw[i] ], _DelC[ _cLaw[i] ] );
			}
			else {
				cout << "cohesive law " << _lawTyp << " not yet implemented!" << endl;
			}

		    fprintf( pFileW, "s(x) = ( x < %12.3e ? s1(x) : 0.0 );\n\n",  _DelC[ _cLaw[i] ] );
		    fprintf( pFileW, "e(x) = x * %12.3e / %12.3e;\n\n",  _E, _Dx );
		    fprintf( pFileW, "set output \"./pngFiles/CohLaw%u.svg\"\n", i + 1);
		    fprintf( pFileW, "set yrange [:%12.3e]\n", _SigC[ _cLaw[i] ]);
		    fprintf( pFileW, "plot s(x) ti 'analytical %u' w l lw 3 , \\\n", _cLaw[i] );
		    fprintf( pFileW, "    './datFiles/cohLaw.dat' usi %u:%u ti 'computed %u' w lp ,\\\n", i*2+2, 2*i+3, _cLaw[i] );
			fprintf( pFileW, "    e(x) ti 'Elastic Modulus' w l lw 3 ;\n\n");
		}
		fclose( pFileW );

		FILE * pFile;
		pFile = fopen( _CohLawFile.c_str(), "w" );
		fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
		fprintf( pFile, " -- MH [DCML] (2010)\n" );
		fprintf( pFile, "# Cohesive Link Information for selected links:");
		for (unsigned i = 0; i < _cLaw.size(); i++) {
		    fprintf( pFile, " %u", _cLaw[i]);
		}    
		fprintf( pFile, "\n");
		fprintf( pFile, "#       time");
		for (unsigned i = 0; i < _cLaw.size(); i++) {
		    fprintf( pFile, "    delta%u    sigma%u", _cLaw[i], _cLaw[i] );
		} 
		fprintf( pFile, "\n");
		fclose( pFile );
	} else {
		_cLaw.resize( cohNums.size() );
		for (unsigned i = 0; i < cohNums.size(); i++){
			_cLaw[i] = cohNums[i];
		}
	}
	return;
}

void CartRing::plotFrags (){

	if (_myid > 0) return;

    // Gnuplot file for fragmentation
    FILE * pFileW;
    std::string fragFile = _path+"/gnuplot/plotFragInfo.plt";		//../results
    pFileW = fopen( fragFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <cartRing.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Fragmentation Information\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"Number of Cracks/Fragments\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/numFrag.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraginfo.dat' usi 1:4 ti 'Sum of Damage' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/fraginfo.dat' usi 1:2 ti '# Cracks' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/fraginfo.dat' usi 1:3 ti '# Frags' w l\n\n" );


    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"stress (Pa)\"\n" );
    fprintf( pFileW, "set output './pngFiles/SigL_R_C.svg'\n");
    fprintf( pFileW, " plot './datFiles/fraginfo.dat' usi 1:11 ti 'SigL'w l,\\\n");
    fprintf( pFileW, "             './datFiles/fraginfo.dat' usi 1:12 ti 'SigR' w l,\\\n");
    fprintf( pFileW, "             './datFiles/fraginfo.dat' usi 1:14 ti 'SigC' w l\n\n");


    fprintf( pFileW, "set logscale y\n" );		//Time-step graph
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"_Dt\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/dt.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:10 ti 'Refinement' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:9 ti 'Time Step Flag' w l\n\n" );

    fclose( pFileW );

    // Prepare Gnuplot data file
    _FragFile = _path+"/datFiles/fraginfo.dat";		//../results
    FILE * pFile;
    pFile = fopen( _FragFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#       time     #cracks       #frags  DamageSum        Mean      Median         Max         Min");
    fprintf( pFile, "       StDev       Range        Skew    Ex. Kurt.       SigL        SigR      SigL*R        SigC");
    fprintf( pFile, "((R*L^2)/|L|) (Locations)\n");
    fclose( pFile );
}

void CartRing::plotHisto () {
	if (_myid > 0) return;

    // Gnuplot file for fragmentation histogram
    FILE * pFileW;
    std::string histoFile = _path+"/gnuplot/plotHisto.plt";		//../results
    pFileW = fopen( histoFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <cartRing.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "set title \"Fragment Length CDF Graph\"\n"); 
    fprintf( pFileW, "set xlabel \"Fragment Length, Lf (m)\"\n" );
    fprintf( pFileW, "set ylabel \"# ( Length > Lf )\"\n" );
    fprintf( pFileW, "set yrange [0:%u]\n", _numFrag);
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/fraginvcdf.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' usi 1:2 ti '' w l;\n\n" );
    fprintf( pFileW, "set boxwidth 0.9 absolute\n" );
    fprintf( pFileW, "set style fill   solid 1.00 border -1\n" );
    fprintf( pFileW, "set title \"Fragmentation Histogram\"\n"); 
    fprintf( pFileW, "set xlabel \"Size Distribution Relative to Max. Frag. Size (Percent)\"\n" );
    fprintf( pFileW, "set ylabel \"Frequency\"\n" );
    fprintf( pFileW, "set xrange [0:100]\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/fragHisto.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' using 3:4:(4) ti '' with boxes;\n" );
    fclose( pFileW );

    // Prepare Gnuplot data file
    _HistoFile = _path+"/datFiles/fraghisto.dat";		//../results
    FILE * pFile;
    pFile = fopen( _HistoFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#Length, Lf   # With Length > Lf   Bin Center   Frequency\n" );
    fclose( pFile );
}

void CartRing::plotSTheta () {
	if (_myid == 0) {
		// Gnuplot file for fragmentation histogram
		FILE * pFileW;
		std::string sThetaFile = _path+"/gnuplot/plotSTheta.plt";	//../results/
		pFileW = fopen( sThetaFile.c_str(), "w" );
		fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
		fprintf( pFileW, "# GNUPLOT file generated by <cartRing.h>");
		fprintf( pFileW, " -- MH[DCML] (2010)\n");
		fprintf( pFileW, "datafile = './datFiles/stresstheta.dat'\n");
		fprintf( pFileW, "stats datafile;\n");
		fprintf( pFileW, "set title \"Cohesive Link Stress vs. Theta Graph\"\n"); 
		fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
		fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
		fprintf( pFileW, "set xrange [0:360]\n");
		fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
		fprintf( pFileW, "set output './pngFiles/stressThetaCL.svg'\n");
		fprintf( pFileW, "plot for[i=1:1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 4:5 ti 'Link Stress' w l;\n\n" );
		fprintf( pFileW, "set title \"Spring Element Stress vs. Theta Graph\"\n"); 
		fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
		fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
		fprintf( pFileW, "set xrange [0:360]\n");
		fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
		fprintf( pFileW, "set output './pngFiles/stressThetaSE.svg'\n");
		fprintf( pFileW, "plot for[i=1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 2:3 ti 'Spring Stress' w l;\n\n" );

		fprintf( pFileW, "set title \"Cohesive Link Damage vs. Theta Graph\"\n"); 
		fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
		fprintf( pFileW, "set ylabel \"Damage\"\n" );
		fprintf( pFileW, "set xrange [0:360]\n");
		fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
		fprintf( pFileW, "set output './pngFiles/stressThetaCLD.svg'\n");
		fprintf( pFileW, "plot for[i=1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 4:6 ti 'Damage' w l;\n\n" );

		fclose( pFileW );
	}

    // Prepare Gnuplot data file
	if (_numprocs == 1) {
		_SThetaFile = _path+"/datFiles/stresstheta.dat";		//../results
	} else {
		_SThetaFile = _path+"/datFiles/stresstheta_" + convertInt(_myid) + ".dat";		//../results
	}
	if (_myid == 0) {	
	    FILE * pFile;
	    pFile = fopen( _SThetaFile.c_str(), "w" );
	    	fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
	    fprintf( pFile, " -- MH [DCML] (2010)\n" );
	    fprintf( pFile, "# Fragmentation Information\n" );
	    fprintf( pFile, "#Time       SprTheta    SprStress   CohTheta    CohStress           i         _Nt\n" );
	    fclose( pFile );
	}
}

void CartRing::display ( const unsigned timStepNumElas,
                     const unsigned timStepNumFrac ) {

    _DisplayFlag = true;
    _DtPrintElas = timStepNumElas;
    _DtPrintFrac = timStepNumFrac;
}

/*------------------------------ P R I V A T E -------------------------------*/

void CartRing::printConnec () const {
	if (_myid > 0) return;
    if ( _Nx < 10 ) {
        printf ( "|--------------------------------------|\n" );
        printf ( "|           Connectivities             |\n" );
        printf ( "|--------------------------------------|\n" );
        printf ( "|      Springs     |   Cohesive Zones  |\n" );
        printf ( "|   n1         n2  |   n1          n2  |\n" );
        printf ( "|------------------|-------------------|\n" );
        for ( unsigned j = 0; j < _Nx; j++ ) {
            printf ( "|   %2d         %2d  |   %2d          %2d  |\n",
                     _SprCon[j].first, _SprCon[j].second,
                     _CohCon[j].first, _CohCon[j].second );
        }
        printf ( "|------------------|-------------------|\n" );
    }
}

void CartRing::printVtk ( const unsigned timStepNum ) const {

    // Build a name for the vtk file
    std::string resuPath = _path+"/vtkFiles/";			//../results
    unsigned zeroNum = 6 - (unsigned) floor( log10( timStepNum ) );
    std::string baseName = "ring_" + convertInt(_myid) + "_";
    for ( unsigned i = 0; i < zeroNum; i++ ) {
        baseName += "0";
    }
    baseName += convertInt(timStepNum);
    std::string vtkFile = resuPath + baseName + ".vtk";

    // Print in the vtk file
    printHeader ( vtkFile );
    printMesh ( vtkFile );
    printPointData ( vtkFile );
    printCellData ( vtkFile );
}

void CartRing::printHeader ( const std::string& vtkFile ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "w" );
    fprintf ( pFile, "# vtk DataFile Version 2.0\n" );
    fprintf ( pFile, "Generated by <ring.h> -- MH [DCML] (2010)\n" );
    fprintf ( pFile, "ASCII\nDATASET UNSTRUCTURED_GRID\n\n" );
    fclose( pFile );
}

void CartRing::printMesh ( const std::string& vtkFile ) const {
	int var = 0;
    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    unsigned nodSize = _NodPos.size();
    fprintf ( pFile, "POINTS %d float\n", (_end-_begin+1)*2+var  );
    for ( unsigned i = 0; i < nodSize; i++ ) {
        double x = _NodPosOrig[i][0];			//NodPos
        double y = _NodPosOrig[i][1];
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", x, y, 0.0 );
    }

    unsigned sprSize = _end-_begin+1;//_SprCon.size();
    fprintf ( pFile, "\nCELLS %d %d\n", sprSize, 3*sprSize );
    for ( unsigned i = 0; i < sprSize; i++ ) {
        fprintf ( pFile, " %12d %12d %12d\n", 2, _SprCon[i].first,
                  _SprCon[i].second );
    }
    fprintf ( pFile, "\nCELL_TYPES %d\n", sprSize );
    for ( unsigned i = 0; i < sprSize; i++ ) {
        fprintf ( pFile, " %12d\n", 3 );
    }
    fprintf ( pFile, "\n" );
    fclose( pFile );
}

void CartRing::printPointData ( const std::string& vtkFile ) const {
	int var = 0;

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    //int pointData = _NodPos.size();
    fprintf ( pFile, "POINT_DATA %d", (_end-_begin+1)*2 +var);
    fprintf ( pFile, "\nVECTORS displacements float\n" );
    for ( unsigned i = 0; i < _Dis.size(); i++ ) {
        double dx = _NodPos[i][0]-_NodPosOrig[i][0];	//Dis[i][0][0]
        double dy = _NodPos[i][1]-_NodPosOrig[i][1];
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", dx, dy, 0.0 );
    }

    fprintf ( pFile, "\nVECTORS velocities float\n" );
    for ( unsigned i = 0; i < _Vel.size(); i++ ) {
        double vx = _Vel[i][0][0];
        double vy = _Vel[i][0][1];
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", vx, vy, 0.0 );
    }
    fprintf ( pFile, "\n" );
    fclose( pFile );
}

void CartRing::printCellData ( const std::string& vtkFile ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    fprintf( pFile, "CELL_DATA %d", (_end-_begin+1) );
    fprintf( pFile, "\nSCALARS stress float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = _begin; i <= _end; i++ ) {
        fprintf( pFile, " %12.3e\n", _Stress[i] );
    }
    fprintf( pFile, "\n" );
    fclose( pFile );
}

void CartRing::printNodalInfo () const {

    if ( _NodesToPlot.size() > 0 ) {
        FILE * pFile;

        for ( unsigned i = 0; i < _NodesToPlot.size(); i++ ) {
            unsigned nodNum = _NodesToPlot[i];
			if (!_local[nodNum]) continue;
            double v_r = 1.0 * _Vel[nodNum][0][0];
            double v_t = 1.0 * _Vel[nodNum][0][1];
            pFile = fopen( _NodeFiles[i].c_str(), "a" );
            fprintf( pFile, "%12.3e", _T );
            fprintf( pFile, "%12.3e", v_r );
            fprintf( pFile, "%12.3e", v_t );
            fprintf( pFile, "\n" );
            fflush( pFile );
            fclose( pFile );
        }
    }
}

void CartRing::printElmInfo () const {

    if ( _ElmsToPlot.size() > 0 ) {
        FILE * pFile;

        for ( unsigned i = 0; i < _ElmsToPlot.size(); i++ ) {
            unsigned elmNum = _ElmsToPlot[i];
			if (elmNum < _begin || elmNum > _end) continue;
            pFile = fopen( _ElmFiles[i].c_str(), "a" );
            fprintf( pFile, "%12.3e", _T );
            fprintf( pFile, "%12.3e", _Stress[elmNum] );
            fprintf( pFile, "\n" );
            fclose( pFile );
        }
    }
}

void CartRing::printGlobalInfo () const {

    if ( _EnrgFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _EnrgFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", _T );
        fprintf( pFile, "%12.3e", _Wspr );
        fprintf( pFile, "%12.3e", _Wcoh[0] );
        fprintf( pFile, "%12.3e", _Wcoh[1] );
        fprintf( pFile, "%12.3e", _WextT );
        fprintf( pFile, "%12.3e", _Wkin );
	fprintf( pFile, "%12.3e", _Wmax * 0.01 );
	fprintf( pFile, "%12.3e", _Wsum );
	fprintf( pFile, "%12.3f", (double)(_tFlag[1]) + .001 );	//Time-step plot
	fprintf( pFile, "%12.3e", _Dt/_Dt_c );
	fprintf( pFile, "%12.3e", _dWcoh[0]);
	fprintf( pFile, "%12.3e", _dWcoh[3]);
	fprintf( pFile, "%12.3e", _Wcoh100[2]);
	fprintf( pFile, "%12.3e", _WsprD);
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void CartRing::printCohLaw () const {

    if ( _CohLawFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _CohLawFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", _T );
		int count = 0;
		for (unsigned i = 0; i < _cLaw.size(); i++ ) {
			if (_cLaw[i] < _begin || _cLaw[i] > _end || _cLaw[i] >= _delta.size()) continue;
		    fprintf( pFile, "%12.3e", _delta[ _cLaw[i] ] ); 	//delta
		    fprintf( pFile, "%12.3e", _sigCoh[ _cLaw[i] ] );	//sigma
			count++;
		}
		if (count == 0) 		    fprintf( pFile, " N/A");	//no cohesive zones on this processor.
        fprintf( pFile, "\n" );
		fclose( pFile );
    }
}

void CartRing::printFrags () {
    unsigned cohNum =19;
    if ( _FragFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _FragFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", _T );
        fprintf( pFile, "%12u", _numFrag );
        fprintf( pFile, "%12u", numFragSymm() );
        fprintf( pFile, "%12.3f", _DSum );
        fprintf( pFile, "%12.3e", _fMean );
        fprintf( pFile, "%12.3e", _fMed );
        fprintf( pFile, "%12.3e", _fMax );
	fprintf( pFile, "%12.3e", _fMin );
	fprintf( pFile, "%12.3e", _fStDev );
	fprintf( pFile, "%12.3e", _fRange );
	fprintf( pFile, "%12.3f", _fSkew );
	fprintf( pFile, "%12.3f", _fExKurtosis );
	double SigR = _Stress[cohNum];
	double SigL = _Stress[ ((cohNum+1) % _Nx) ];
	double SigC = _sigCoh[cohNum];
	fprintf( pFile, "%12.3e", SigL );			//SigL
	fprintf( pFile, "%12.3e", SigR );			//SigR
	fprintf( pFile, "%12.3e", SigR * SigL);			//SigL*SigR
	fprintf( pFile, "%12.3e", SigC );			//SigC
	if (SigR * SigL > 0 ) {
	    fprintf( pFile, "%12.3e", SigR * SigL * SigL / fabs(SigL));	//SigL*SigR*sign(SigL)
	}
	if (_numFrag <= 10){
	    for (unsigned i = 0; i < _fragLoc.size(); i++){
		fprintf( pFile, "%12u", _fragLoc[i] );
	    }
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void CartRing::printSTheta () const {
    if ( _SThetaFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _SThetaFile.c_str(), "a" );
        //fprintf( pFile, "%12.3e", _T );
	for (unsigned i = 0; i < _Nx; i++) {
		if (i < _begin || i > _end) continue;
	    double sprTheta = (double)(360*(i+0.5))/(double)(_Nx);
	    double cohTheta = (double)(360*(i+1))/(double)(_Nx);
	    fprintf( pFile, "%12.3e", _T );
	    fprintf( pFile, "%12.3f", sprTheta );
        fprintf( pFile, "%12.3e", _Stress[i] );
        fprintf( pFile, "%12.3f", cohTheta );
        fprintf( pFile, "%12.3e", _sigCoh[i] );
        fprintf( pFile, "%12.3e", _D[i][0] );
        fprintf( pFile, "%12.3f", (double)(i) );
        fprintf( pFile, "%12.3f", (double)(_Nt) );
	    fprintf( pFile, "\n" );
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void CartRing::printClean () const {
	//if (_myid > 0) return;

    std::string cleanPath = _path+"/clean.sh";
    FILE * pFile;
    pFile = fopen( cleanPath.c_str(), "w" );
    fprintf( pFile, "#!/bin/bash\n\n" );
    fprintf( pFile, "# Go to results directory\n" );
    fprintf( pFile, "cd %s\n\n", _path.c_str() );
    fprintf( pFile, "# Remove the data files\n" );
    fprintf( pFile, "cd ./datFiles/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "cd ./automatedRuns/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "# Remove the gnuplot files\n" );
    fprintf( pFile, "cd ./gnuplot/ ; rm *.plt; cd -\n\n" );
    fprintf( pFile, "# Remove the png/svg files\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.png; cd -\n\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.svg; cd -\n\n" );
    fprintf( pFile, "# Remove the vtk files\n" );
    fprintf( pFile, "cd ./vtkFiles/; find . -name \"*.vtk\" -print0 | xargs -0 rm -f; cd -\n\n" );
    fprintf( pFile, "# Remove plot.sh\n" );
    fprintf( pFile, "rm plot.sh\n" );
    fclose( pFile );
    std::string shellCmd = "chmod u+x " + cleanPath;
    //int status = system( shellCmd.c_str() );
	system( shellCmd.c_str() );

}
