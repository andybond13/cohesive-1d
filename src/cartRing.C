/*******************************************************************************

  Class <cartRing> 

  Author: Martin Hautefeuille
          Duke Computational Mechanics Lab (DCML)
          Duke University - Durham, NC (USA)
  E-mail: mh186@duke.edu

  Copyright (c) 2010 Martin Hautefeuille. All rights reserved. No warranty. No
  liability.

*******************************************************************************/
#include "cartRing.h"
#include "mpi.h"
#include <stdlib.h>
#include <time.h>
#include <iostream>
#include <fstream>
#include <stdio.h>
#include <assert.h>
#include <math.h>
#include <sys/stat.h>
//#include <str_ops.hpp>
#include <time.h>
//#include <valarray>
using namespace std;
using namespace MPI;

#define PI 3.14159265358979323846

/*******************************************************************************

                M E T H O D S    F O R    R E S O L U T I O N 

*******************************************************************************/

/*------------------------------- P U B L I C --------------------------------*/

CartRing::CartRing ( const double length, const double crossSec,
                     const double density, const double YoungMod,
                     const int nodNum, const std::string path  ) {


	//begin parallel specification
	MPI::Init(); 
	_numprocs = MPI::COMM_WORLD.Get_size(); 
	_myid = MPI::COMM_WORLD.Get_rank(); 
	MPI::COMM_WORLD.Barrier();

    // affect input values to attributes
    _L = length;
    _A = crossSec;
    _rho = density;
    _E = YoungMod;
    _Nx = nodNum;
    _R0 = _L/(2*PI);
    _c = sqrt( _E / _rho );
    _path = path;
	_defectRange = -1.0;

	//domain decomposition
	domainDecomposition();	

     //Initialize time clock to generate time stamp for log filename
	time_t rawtime;
	time ( &rawtime );
	struct tm * tinf = localtime ( &rawtime );

	//initialize clock for run-time calculation
	std::clock_t _start;
	_start = std::clock();

     // name for the log file
     std::string minutes = ( tinf->tm_min < 10 )
                         ? "0"+convertInt(tinf->tm_min)
                         : convertInt(tinf->tm_min);
    _logPath = _path + "/cartRing" + convertInt( _Nx ) + "_"
             + convertInt( tinf->tm_mon+1 ) + "-"
             + convertInt( tinf->tm_mday+0 ) + "-"
             + convertInt( tinf->tm_year+1900 ) + "_"
             + convertInt( tinf->tm_hour ) + ":"
             + minutes + "_p" + convertInt(_myid) + ".log";

	// clean the directory tree
	printClean();
	std::string shellCmd = _path+"/clean.sh";

	if (_myid == 0) {

		FILE * pFile;
		pFile = fopen ( _logPath.c_str(), "w" );	//Try to create logfile
		if ( !pFile ) {				//Create structure if it doesn't exist
		    // create the directory tree
		    mkdir( _path.c_str(), 0777 );		//allow read, write, execute for all users
		    std::string datPath = _path+"/datFiles";
		    mkdir( datPath.c_str(), 0777 );
		    std::string pngPath = _path+"/pngFiles";
		    mkdir( pngPath.c_str(), 0777 );
		    std::string gnuPath = _path+"/gnuplot";
		    mkdir( gnuPath.c_str(), 0777 );
		    std::string vtkPath = _path+"/vtkFiles";
		    mkdir( vtkPath.c_str(), 0777 );
		    //printClean();
		    pFile = fopen( _logPath.c_str(), "w" );	//reopen
		} else {
		    /*// clean the directory tree
		    printClean();
		    std::string shellCmd = _path+"/clean.sh";*/

			//make sure clean.sh exists
			fstream myFile(shellCmd.c_str());
			if (!myFile.good()) printClean();
			system( shellCmd.c_str() );
		}
		//Print logfile title block
		fprintf ( pFile, "## Log file for cartring.h\n" );
		fprintf ( pFile, "##   Number of elements: %u\n", _Nx );
		fprintf ( pFile, "##   Start on: %s\n\n", asctime( tinf ) );
		fclose( pFile );

	}

    // build the mesh
    buildDiscretization ();

    // set _DisplayFlag and _tFlag to false and zero
    _DisplayFlag = false;
    _tFlag.resize(2);
    _tFlag[0] = 0;
    _tFlag[1] = 0;
}

//Empty constructor for CTL
CartRing::CartRing() {}

//Destructor
CartRing::~CartRing () {
	if (_myid == 0) {
		// create a plot file if necessary
		if ( _NodesToPlot.size() != 0 || _ElmsToPlot.size() != 0 ) {
		    std::string plotFil = _path+"/plot.sh";		//"../results/plot.sh"
		    FILE * pFileP;
		    pFileP = fopen( plotFil.c_str(), "w" );
		    fprintf( pFileP, "#!/bin/bash\n" );
		    fprintf( pFileP, "# shell script generated by <ring.h>" );
		    fprintf( pFileP, " -- MH [DCML] (2010)\n\n" );
		    if ( _NodesToPlot.size() != 0 ) {
		        std::string velRFil = "./gnuplot/plotRadialVelo.plt";
		        fprintf( pFileP, "gnuplot %s\n", velRFil.c_str() );
		        std::string velTFil =  "./gnuplot/plotCircumVelo.plt";
		        fprintf( pFileP, "gnuplot %s\n", velTFil.c_str() );
		    }
		    if ( _ElmsToPlot.size() != 0 ) {
		        std::string streFil = "./gnuplot/plotStre.plt";
		        fprintf( pFileP, "gnuplot %s\n", streFil.c_str() );
		    }
		    if ( _EnrgFile.size() != 0 ) {
		        std::string enrgFil = "./gnuplot/plotEnrg.plt";
		        fprintf( pFileP, "gnuplot %s\n", enrgFil.c_str() );
		    }
		    if ( _CohLawFile.size() != 0 ) {
		        std::string cohLawFil = "./gnuplot/plotCohLaw.plt";
		        fprintf( pFileP, "gnuplot %s\n", cohLawFil.c_str() );
		    }
		    if ( _FragFile.size() != 0 ) {
		        std::string fragFil = "./gnuplot/plotFragInfo.plt";
		        fprintf( pFileP, "gnuplot %s\n", fragFil.c_str() );
		    }
		    if ( _HistoFile.size() != 0 ) {
		        std::string histoFil = "./gnuplot/plotHisto.plt";
		        fprintf( pFileP, "gnuplot %s\n", histoFil.c_str() );
		    }
		    if ( _SThetaFile.size() != 0 ) {
		        std::string sThetaFil = "./gnuplot/plotSTheta.plt";
		        fprintf( pFileP, "gnuplot %s\n", sThetaFil.c_str() );
		    }
		    fprintf( pFileP, "\n/usr/bin/open -a \"/Applications/Google Chrome.app\" ./pngFiles/*.svg &\n" );
		    fclose( pFileP );
		    chmod( plotFil.c_str(), 0775 );
		}
	}
}

void CartRing::setCohLaw ( const std::string& lawTyp,
                           const std::vector<std::vector<double> >& param ) {

	//save cohesive law type
	_lawTyp = lawTyp;

	//assume downward linear / Ortiz form
    //If sigma (maximum traction) and delta (final opening) are specified
    if ( lawTyp.compare( 0 , 5, "LINSD" ) == 0 ) {
        if ( param.size() >= 2 ) {
            // _SigC
            if ( param[0].size() == 1 ) {
                _SigC.assign( _Nx, param[0][0] );
            } else if ( param[0].size() == _Nx ) {
                _SigC.assign( param[0].begin(), param[0].end() );
            } else {
                std::cout << "param[0].size() and # of cohesive links "
                          << "mismatch!!\n"
                          << "only the first value " << param[0][0]
                          << " is considered for all the elements"
                          << std::endl;
                _SigC.assign( _Nx, param[0][0] );
            }
            // _DelC
            if ( param[1].size() == 1 ) {
                _DelC.assign( _Nx, param[1][0] );
            } else if ( param[1].size() == _Nx ) {
                _DelC.assign( param[1].begin(), param[1].end() );
            } else {
                std::cout << "param[1].size() and # of cohesive links"
                          << " mismatch!!\n"
                          << "only the first value " << param[1][0]
                          << " is considered for all the elements"
                          << std::endl;
                _DelC.assign( _Nx, param[1][0] );
            }
        } else {
             std::cout << "LINSD requires two parameters sigma_c and delta_c"
                       << std::endl; 
	     	assert(1==0);
        }
    } else if ( lawTyp.compare( 0, 5, "LINSG" ) == 0 ) {		//if sigma and energy are specified
        if ( param.size() >= 2 ) {
            // _SigC
            if ( param[0].size() == 1 ) {
                _SigC.assign( _Nx, param[0][0] );
            } else if ( param[0].size() == _Nx ) {
                _SigC.assign( param[0].begin(), param[0].end() );
            } else {
                std::cout << "param[0].size() and # of cohesive links"
                          << " mismatch!!\n"
                          << "only the first value " << param[0][0]
                          << " is considered for all the elements"
                          << std::endl;
                _SigC.assign( _Nx, param[0][0] );
            }
            // _DelC
            if ( param[1].size() == _Nx ) {
                _DelC.resize( _Nx );
                if ( param[0].size() != _Nx ) {
                    for ( unsigned i = 0; i < _Nx; i++ ) {
                        _DelC[i] = 2 * param[1][i] / param[0][0];	//Gc = sigma*delta/2; delta=2*Gc/s
                    }
                } else {
                    for ( unsigned i = 0; i < _Nx; i++ ) {
                        _DelC[i] = 2 * param[1][i] / param[0][i];
                    }
                }
            } else {
                if ( param[0].size() != _Nx ) {
                    _DelC.assign( _Nx, 2 * param[1][0] / param[0][0] );
                } else {
                    _DelC.resize( _Nx );
                    for ( unsigned i = 0; i < _Nx; i++ ) {
                        _DelC[i] = 2 * param[1][0] / param[0][i];
                    }
                }
                if ( param[1].size() != 1 ) {
                    std::cout << "param[1].size() and # of cohesive links"
                              << " mismatch!!\n"
                              << "only the first value " << param[1][0]
                              << " is considered for all the elements"
                              << std::endl;
                }
            }
        } else {
             std::cout << "LINSG requires two parameters sigma_c and delta_c"
                       << std::endl; 
			assert(1==0);
        }
	} else if ( lawTyp.compare( 0, 6, "SQRTSG" ) == 0 ) {		//if sigma and energy are specified - square root curve - Nicholas Moes TLS-based
        if ( param.size() >= 2 ) {
            // _SigC
            if ( param[0].size() == 1 ) {
                _SigC.assign( _Nx, param[0][0] );
            } else if ( param[0].size() == _Nx ) {
                _SigC.assign( param[0].begin(), param[0].end() );
            } else {
                std::cout << "param[0].size() and # of cohesive links"
                          << " mismatch!!\n"
                          << "only the first value " << param[0][0]
                          << " is considered for all the elements"
                          << std::endl;
                _SigC.assign( _Nx, param[0][0] );
            }
            // _DelC
            if ( param[1].size() == _Nx ) {
                _DelC.resize( _Nx );
                if ( param[0].size() != _Nx ) {
                    for ( unsigned i = 0; i < _Nx; i++ ) {
                        _DelC[i] = 3 * param[1][i] / param[0][0];	//Gc = sigma*delta/3; delta=3*Gc/sigmac
                    }
                } else {
                    for ( unsigned i = 0; i < _Nx; i++ ) {
                        _DelC[i] = 3 * param[1][i] / param[0][i];
                    }
                }
            } else {
                if ( param[0].size() != _Nx ) {
                    _DelC.assign( _Nx, 3 * param[1][0] / param[0][0] );
                } else {
                    _DelC.resize( _Nx );
                    for ( unsigned i = 0; i < _Nx; i++ ) {
                        _DelC[i] = 3 * param[1][0] / param[0][i];
                    }
                }
                if ( param[1].size() != 1 ) {
                    std::cout << "param[1].size() and # of cohesive links"
                              << " mismatch!!\n"
                              << "only the first value " << param[1][0]
                              << " is considered for all the elements"
                              << std::endl;
                }
            }
        } else {
             std::cout << "SQRTSG requires two parameters sigma_c and delta_c"
                       << std::endl; 
			assert(1==0);
        }

    } else {
        std::cout << lawTyp << " has not yet been implemented!!" << std::endl;
		assert(1==0);
    }

    // resize _ActivCoh, _D, _delta, _and _sigCoh
    _ActivCoh.assign( _Nx, false );
    _D.resize( _Nx );
    _delta.resize( _Nx );
    _sigCoh.resize( _Nx );
    for ( unsigned i = _begin; i <= _end; i++ ) {
        _D[i].resize(2);
    }
}

void CartRing::applyForc ( const std::string& loadTyp,
                           const std::string& loadDir,
                           const double loadVal ) {

    unsigned type = 0;		//temporary variable for loading rate - 1 or 2,constant or linear
    if ( loadTyp.compare( 0, 4, "CONS") == 0 ) {
        type = 1;
    } else if ( loadTyp.compare( 0, 4, "LINE") == 0 ) {
        type = 2;
    } else {
        std::cout << "Load type " << loadTyp << " not yet implemented!"
                  << std::endl;
		assert(1==0);
    }

    if ( loadDir.compare( 0, 5, "RADIA") == 0 ) {	//a radial force - Assign type and value to NFBC & VFBC[0]
        _NodForcBC[0] = type;
        _ValForcBC[0] = loadVal;
    } else if ( loadDir.compare( 0, 5, "THETA") == 0 ) {	//a circumferencial force - Assign type and value to NFBC & VFBC[1]
        _NodForcBC[1] = type;
        _ValForcBC[1] = loadVal;
    } else {
        std::cout << "Direction " << loadDir << " unknown !" << std::endl; 
		assert(1==0);
    }
}

void CartRing::applyVel (  const std::string& velDir, const double velVal  ) {
    //Constant Velocity / Strain Rate Case
    initVel(velDir, velVal);	//initialize velocity, add it to w_ext
    _ConstSRFlag = 1;		//flag that indicates this case - constant target strain rate
    if ( velDir.compare( 0, 5, "RADIA") == 0 ) {	//a radial velocity - Assign direction and value to VVBC
        _ValVelBC[0] = 1;
        _ValVelBC[1] = velVal;
    } else if ( velDir.compare( 0, 5, "THETA") == 0 ) {	//a circumferential/rotational velocity - Assign direction and value to VVBC
        _ValVelBC[0] = 2;
        _ValVelBC[1] = velVal;
    } else {
        std::cout << "Direction " << velDir << " unknown! " << std::endl; 
		assert(1==0);
    }
}

void CartRing::initVel ( const std::string& velDir, const double velVal ) {
    //Determine loading direction	
    if ( velDir.compare( 0, 5, "RADIA") == 0 ) {	//a radial velocity
        for ( unsigned i = 0; i < _Vel.size(); i++ ) {
			if (!_local[i]) continue;
            _Vel[i][0][0] = velVal * cosTheta(i);	//initialize velocity
            _Vel[i][0][1] = velVal * sinTheta(i);
        }
	//_ValForcBC[0] = velVal;		//????? I do not know why this is here,
    } else if ( velDir.compare( 0, 5, "THETA") == 0 ) {//a circumferential/rotational velocity
        for ( unsigned i = 0; i < _Vel.size(); i++ ) {
			if (!_local[i]) continue;
            _Vel[i][0][0] = -1.0 * velVal * sinTheta(i);//initialize velocity
            _Vel[i][0][1] = velVal * cosTheta(i);
        }
    } else {
        std::cout << "Direction " << velDir << " unknown! " << std::endl; 
		assert(1==0);
    }
     //count initial velocity as an initial external work/given energy
    _Wext += 0.5 * (_m * 2 * _Nx) * pow( velVal , 2) * (double)(_end-_begin+1)/(double)_Nx;
}

void CartRing::solve ( const double endTime, const unsigned printFrequency, const double refine, const bool allowPlateauEnd, const bool checkEnergy ) {

	//set some global variables
	_allowPlateauEnd = allowPlateauEnd;
	_checkEnergy = checkEnergy;

	//synchronize
	MPI::COMM_WORLD.Barrier();

    // Print stuff to vtk file
    if ( _DisplayFlag ) {
        printVtk( _Nt );
    }

	//begin time-step loop
    while (( _T < endTime ) && (_stopFlag == false)) {

		//synchronize
		MPI::COMM_WORLD.Barrier();

        // Compute the time-step
        /*
            _Dt = alpha * _Dt_c with 0.8 < alpha < 0.98
            see [Belytschko, pp. 315]
        */ 
        _Dt = 0.8 * _Dt_c;
		timeStepRefine(refine);		//refine timestep if needed using the time-step flags.

        // Increase current time and time-step, update time-step flags
        _T += _Dt;
        _Nt++;
		_tFlag[0] = _tFlag[1];	//save current time-step flag
		_tFlag[1] = 0;		//initialize new time-step flag
		_stopFlag = false;	//initialize stop flag

        // Explicit Newmark
        MPI::COMM_WORLD.Barrier(); NewmarkPred();
        MPI::COMM_WORLD.Barrier(); NewmarkReso();
        MPI::COMM_WORLD.Barrier(); NewmarkCorr();

		//Check stability and decide on adaptive time-stepping
	 	checkStable();

		//Count the number of fragments
		fragCount();

        // Energy balance check
        energBalance();

        // Update
		MPI::COMM_WORLD.Barrier();
        update();
		MPI::COMM_WORLD.Barrier();
        // Print stuff
        if ( _DisplayFlag ) {
			if (_numFrag >= 1) {
		    		if ( _Nt % _DtPrintFrac == 0 ) {	//Use fracture print frequency
		                printVtk( _Nt );
				}
			} else {
		    	    if ( _Nt % _DtPrintElas == 0 ) {	//Use elastic print frequency
		     	   printVtk( _Nt );
				}
            }
        }
		//print stress vs. theta graphs
        if ( _Nt % _Nx == 0 ) {
	    		printSTheta();
		}

		//print the rest of the table/graph data
		if ( (( _Nt - 1 ) % printFrequency) == 0 ) {
		        printNodalInfo();
		        printElmInfo();
			printCohLaw();
		        printFrags();
			printGlobalInfo();
		}

		//synchronize
		MPI::COMM_WORLD.Barrier();
    }

	if (_myid == 0 ) {
		std::cout << "---------------------------" << std::endl;
		std::cout << "Execution Finished" << std::endl;
		std::cout << "Number of Fragments:   " << _numFrag << std::endl;
		std::cout << "Number of Iterations:  " << _Nt << std::endl;
		std::cout << "Final Cohesive Energy: " << _Wcoh[0] << std::endl;
		std::cout << "Final Stability Ratio: " << _Wsum / _Wmax << std::endl;
		std::cout << "---------------------------" << std::endl;

		//Determine finishing time
		time_t rawtime;
		time ( &rawtime );
		struct tm * tinf = localtime ( &rawtime );

		//Close out log file
		FILE * pFile;
		pFile = fopen ( _logPath.c_str(), "a" );
		fprintf( pFile, "\n\n## Execution finished\n" );
		fprintf( pFile, "##    time: %s", asctime( tinf ) );
		fprintf( pFile, "##    number of fragments: %u\n", _numFrag );
		fprintf( pFile, "##    number of iterations: %u\n", _Nt );
		fprintf( pFile, "##    final cohesive energy: %e\n", _Wcoh[0] );
		fprintf( pFile, "##    final stability ratio: %e\n", _Wsum/_Wmax );
		fclose( pFile );
	}

	//end parallel run
	MPI::COMM_WORLD.Barrier(); MPI::COMM_WORLD.Allreduce ( &_WsprD, &_WsprD, 1, MPI::DOUBLE, MPI_SUM);
	MPI::Finalize(); 

}

void CartRing::printHisto() {
	if (_myid > 0) return;

    // Prints Histogram and scaled 1-cdf figure
    if (_numFrag > 1) {
        plotHisto();
		_fragInvCDF.resize(2);
		_fragInvCDF[0].resize(1000);	//a length, from zero to the max. fragment size
		_fragInvCDF[1].resize(1000);	//number of fragments larger than this length
		_fHisto.assign(25, 0);		//number of bins for the fragment histogram
	
		//Histogram - 25 bins
		 double max = _fMax;	//size
		//Step through fragment length list; increase count in the bin if fragment fits
		for (unsigned k = 0; k < _fragLength.size(); k++){
			if (_fragLength[k] < max * 0.04){
			_fHisto[0] += 1;
			}
			if ((_fragLength[k] < max * 0.08) && (_fragLength[k] >= max * 0.04)) {
			_fHisto[1] += 1;
			}
			if ((_fragLength[k] < max * 0.12) && (_fragLength[k] >= max * 0.08)) {
			_fHisto[2] += 1;
			}
			if ((_fragLength[k] < max * 0.16) && (_fragLength[k] >= max * 0.12)) {
			_fHisto[3] += 1;
			}
			if ((_fragLength[k] < max * 0.20) && (_fragLength[k] >= max * 0.16)) {
			_fHisto[4] += 1;
			}
			if ((_fragLength[k] < max * 0.24) && (_fragLength[k] >= max * 0.20)) {
			_fHisto[5] += 1;
			}
			if ((_fragLength[k] < max * 0.28) && (_fragLength[k] >= max * 0.24)) {
			_fHisto[6] += 1;
			}
			if ((_fragLength[k] < max * 0.32) && (_fragLength[k] >= max * 0.28)) {
			_fHisto[7] += 1;
			}
			if ((_fragLength[k] < max * 0.36) && (_fragLength[k] >= max * 0.32)) {
			_fHisto[8] += 1;
			}
			if ((_fragLength[k] < max * 0.40) && (_fragLength[k] >= max * 0.36)) {
			_fHisto[9] += 1;
			}
			if ((_fragLength[k] < max * 0.44) && (_fragLength[k] >= max * 0.40)) {
			_fHisto[10] += 1;
			}
			if ((_fragLength[k] < max * 0.48) && (_fragLength[k] >= max * 0.44)) {
			_fHisto[11] += 1;
			}
			if ((_fragLength[k] < max * 0.52) && (_fragLength[k] >= max * 0.48)) {
			_fHisto[12] += 1;
			}
			if ((_fragLength[k] < max * 0.56) && (_fragLength[k] >= max * 0.52)) {
			_fHisto[13] += 1;
			}
			if ((_fragLength[k] < max * 0.60) && (_fragLength[k] >= max * 0.56)) {
			_fHisto[14] += 1;
			}
			if ((_fragLength[k] < max * 0.64) && (_fragLength[k] >= max * 0.60)) {
			_fHisto[15] += 1;
			}
			if ((_fragLength[k] < max * 0.68) && (_fragLength[k] >= max * 0.64)) {
			_fHisto[16] += 1;
			}
			if ((_fragLength[k] < max * 0.72) && (_fragLength[k] >= max * 0.68)) {
			_fHisto[17] += 1;
			}
			if ((_fragLength[k] < max * 0.76) && (_fragLength[k] >= max * 0.72)) {
			_fHisto[18] += 1;
			}
			if ((_fragLength[k] < max * 0.80) && (_fragLength[k] >= max * 0.76)) {
			_fHisto[19] += 1;
			}
			if ((_fragLength[k] < max * 0.84) && (_fragLength[k] >= max * 0.80)) {
			_fHisto[20] += 1;
			}
			if ((_fragLength[k] < max * 0.88) && (_fragLength[k] >= max * 0.84)) {
			_fHisto[21] += 1;
			}
			if ((_fragLength[k] < max * 0.92) && (_fragLength[k] >= max * 0.88)) {
			_fHisto[22] += 1;
			}
			if ((_fragLength[k] < max * 0.96) && (_fragLength[k] >= max * 0.92)) {
			_fHisto[23] += 1;
			}
			if ((_fragLength[k] <= max) && (_fragLength[k] >= max * 0.96)) {
			_fHisto[24] += 1;
			}
		}

		//Open file to record histogram and 1-cdf data
		if ( _HistoFile.size() > 0 ) {
			FILE * pFile;
			pFile = fopen( _HistoFile.c_str(), "a" );
			double j = 0;
			for (unsigned i = 0; i < 1000; i++) {

				//grab the 1-cdf data; 
				unsigned count = 0;
				j = max * (i / 1000.0);	//from 0 to max length, 1000 increments
				for (unsigned k = 0; k < _numFrag; k++) {
					if (_fragLength[k] > j) {		//if frag length greater than j, add to count
						count += 1;
					}
				}
		
				//save to vector
				_fragInvCDF[0][i] = j;
				_fragInvCDF[1][i] = (double)count;
				fprintf( pFile, "%12.3e %u", j, count);		//print to file

				//print histogram info to file - relative size (% of max frag length) & count
				if (i < 25) {	//piggybacking the for loop, only need the first 25
					fprintf( pFile, " %f %u", (double)(i*4+2), _fHisto[i] );
				} else {
					fprintf( pFile, " 0 0");
				}
				fprintf( pFile, "\n" );
			}


			//print raw fragment sizes to file
			fprintf( pFile, "Sizes: \n" );
			for (unsigned k = 0; k < _fragLength.size(); k++){
				fprintf( pFile, "%12.3e \n", _fragLength[k] );
			}

			fclose( pFile );
		}
    }
}

void CartRing::grabInfo (double& runTime, unsigned& numFrag, unsigned& nIter, double& Wcoh0, double& Wsum,
				double& Wmax, std::vector<double>& fragLength, double& meanFragLength, double& WsprD,
				std::vector<unsigned>& fHisto, std::vector<std::vector<double> >& fragInvCDF){
    //Grabs information from a completed run and returns it to the post-processor
    //Returns all values
	if (_myid > 0) return;
    runTime = ( (double)std::clock() - (double)_start ) / (double) CLOCKS_PER_SEC;
    numFrag = _numFrag;
    nIter = _Nt;
    Wcoh0 = _Wcoh[0];
    Wsum = _Wsum;
    Wmax = _Wmax;
    WsprD = _WsprD;
    fragLength = _fragLength;
    meanFragLength = _fMean;
    fHisto = _fHisto;
    fragInvCDF = _fragInvCDF;
    
}

void CartRing::grabInfo (double& runTime, unsigned& numFrag, unsigned& nIter, double& Wcoh0, double& Wsum,
				double& Wmax, double& meanFragLength, double& WsprD){
    //Grabs information from a completed run and returns it to the post-processor
    //Returns doubles only
	if (_myid > 0) return;
    runTime = ( (double)std::clock() - (double)_start ) / (double) CLOCKS_PER_SEC;
    numFrag = _numFrag;
    nIter = _Nt;
    Wcoh0 = _Wcoh[0];
    Wsum = _Wsum;
    Wmax = _Wmax;
    meanFragLength = _fMean;
    WsprD = _WsprD;
    
}

void CartRing::defectLimit (const double& defectRange) {
    //Assign defect limit range as a global variable
    _defectRange = defectRange;
}

/*------------------------------ P R I V A T E -------------------------------*/

void CartRing::domainDecomposition() {

	_local = vector<unsigned>(2*_Nx);				//list of locally-owned nodes (boolean: 1 = local, 0 = not)
	_owner = vector<unsigned>(2*_Nx);				//list of owner of nodes
	vector<unsigned> owner = vector<unsigned>(2*_Nx); //list of owner of nodes - local, used to build global one
	_begin = (_myid*_Nx)/_numprocs;			//first node that this processor owns
	_end = ((_myid+1)*_Nx)/_numprocs-1; 		//last node that this processor owns

	//assign whether the node is to be owned locally or not
	for (unsigned i = 0; i < 2*_Nx; ++i) {
	
		if ((i >= 2*_begin+1 && i <= 2*_end+2) || (i == 0 && _myid == _numprocs-1)) {
			_local[i] = true;
			owner[i] = _myid;
		} else {
			_local[i] = false;
		}
	}
	
	//distribute who owners of nodes are
	//synchronize
	MPI::COMM_WORLD.Barrier();
	MPI::COMM_WORLD.Allreduce (&owner[0] , &_owner[0] , (int)2*_Nx , MPI::INT ,MPI::SUM);
	
	//check that everything lines up locally	 
	for (unsigned i = 0; i < 2*_Nx; ++i) { 
		if (_local[i]) assert(_owner[i] == _myid);
	}

	//synchronize
	MPI::COMM_WORLD.Barrier();

}

std::string CartRing::convertInt(int number) const
{
    if (number == 0)
        return "0";
    string temp="";
    string returnvalue="";
	//read from back
    while (number>0)
    {
        temp+=number%10+48;
        number/=10;
    }
    for (unsigned i=0;i<temp.length();i++)
        returnvalue+=temp[temp.length()-i-1];
    return returnvalue;
}

void CartRing::buildDiscretization () {

    // Build _NodPos, assign node locations
    _NodPos.resize( 2*_Nx ); 		//node locations[node number][x or y]
    _NodPosOrig.resize( 2*_Nx ); 
    for ( unsigned i = 1; i <= _Nx; i++ ) { 
        unsigned k = ( 2*i ) % ( 2*_Nx ); 
        _NodPos[2*i-1].resize( 2 ); 
        _NodPos[k].resize( 2 ); 
        _NodPosOrig[2*i-1].resize( 2 ); 
        _NodPosOrig[k].resize( 2 ); 
        double theta = 2*PI*i/_Nx; 
        _NodPos[2*i-1][0] = _R0 * cos( theta ); 
        _NodPos[2*i-1][1] = _R0 * sin( theta ); 
        _NodPos[k][0] = _R0 * cos( theta ); 
        _NodPos[k][1] = _R0 * sin( theta ); 
        _NodPosOrig[2*i-1][0] = _R0 * cos( theta ); 
        _NodPosOrig[2*i-1][1] = _R0 * sin( theta ); 
        _NodPosOrig[k][0] = _R0 * cos( theta ); 
        _NodPosOrig[k][1] = _R0 * sin( theta ); 
    } 

    // Build connectivities - assign nodes to springs and links
    _SprCon.resize( _Nx );
    _CohCon.resize( _Nx );
    _NodCon.resize( _NodPos.size() );
    for ( unsigned i = 0; i < _Nx; i++ ) {
        // Build _SpringConnec and _NodeConnec accordingly
        _SprCon[i].first = 2*i;
        _NodCon[2*i].first = i;
        _SprCon[i].second = 2*i+1;
        _NodCon[2*i+1].first = i;
        // Build _CoheJointConnec and _NodeConnec accordingly
        unsigned k = ( 2*(i+1) ) % ( 2*_Nx );
        _CohCon[i].first = 2*i+1;
        _NodCon[2*i+1].second = i;
        _CohCon[i].second = k;
        _NodCon[k].second = i;
    }
    printConnec();	//print table of connections for for small meshes

    // Compute the element size
    std::vector<double> firstElmVec = sprVec ( 0 );
    _Dx = sqrt( pow( firstElmVec[0], 2 ) + pow( firstElmVec[1], 2 ) );	//initial element size
    _m = 0.5 * _rho * _A * _Dx;						//element half-mass, nodal mass

    // Compute critical time-step
    _Dt_c = _Dx / _c;

    // Resize the kinematics
    _Dis.resize( _NodPos.size() );		//displacement[node #][initial, predict, correct][x or y]
    _Vel.resize( _NodPos.size() );
    _Acc.resize( _NodPos.size() );
    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
        _Dis[i].resize( 3 );
        _Dis[i][0].resize( 2 );
        _Dis[i][1].resize( 2 );
        _Dis[i][2].resize( 2 );
        _Vel[i].resize( 3 );
        _Vel[i][0].resize( 2 );
        _Vel[i][1].resize( 2 );
        _Vel[i][2].resize( 2 );
        _Acc[i].resize( 2 );
        _Acc[i][0].resize( 2 );
        _Acc[i][1].resize( 2 );
    }

    // Resize forces
    _Fspr.resize( _NodPos.size() );
    _Fcoh.resize( _NodPos.size() );
    _Fext.resize( _NodPos.size() );
    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
        _Fspr[i].resize( 2 );
        _Fcoh[i].resize( 2 );
        _Fext[i].resize( 2 );
        _Fext[i][0].resize( 2 );
        _Fext[i][1].resize( 2 );
    }

    // Resize dual variables
    _Stress.resize( _Nx );
    _sprDamage.assign(_Nx,0.0);

    // Resize & initialize _Wcoh & _Wspr & _Wsum & _numFrag & _DSum & _stopFlag
    _Wcoh.resize(2);
    _dWcoh.assign(5,0.0);
    _Wcoh100.assign(4,0.0);
    _Wspr = 0;
    _Wsum = 0;
    _Wext = 0.0;
    _numFrag = 0;
    _DSum = 0;
    _stopFlag = false;

    //Initialize constant strain rate flag
    _ConstSRFlag = 0;

    // Resize vectors for BC
    _NodForcBC.resize(2);
    _ValForcBC.resize(2);
    _ValVelBC.resize(2);
    _VelForcReq.resize( _NodPos.size() );
    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
        _VelForcReq[i].resize( 2 );
    }

    // Set _T and _Nt to zero
    _T = 0.0;
    _Nt = 0; 

	//define boundary nodes
	defineBoundaryNodes();
	MPI::COMM_WORLD.Barrier();

}

void CartRing::NewmarkPred () {

    for ( unsigned i = 0; i < 2*_Nx; i++ ) {
		if (!_local[i]) continue;

        // Predict Velocities
        _Vel[i][1][0] = _Vel[i][0][0] + 0.5 * _Dt * _Acc[i][0][0];
        _Vel[i][1][1] = _Vel[i][0][1] + 0.5 * _Dt * _Acc[i][0][1];

        // Apply Boundary Conditions
        /* NOT YET SURE ON HOW TO DO IT */
        // Predict relative displacements
        _Dis[i][1][0] = _Dt * _Vel[i][1][0];
        _Dis[i][1][1] = _Dt * _Vel[i][1][1];
    }
}

void CartRing::NewmarkReso () {

	//Update boundary spring locations to be used for ->stress->sprVecPred and -sprVecPred, if necessary
	exchangeBoundaryNodes();

    // Build the spring force vector, and spring energy values
    _Wspr = 0.0;
    _WsprD = 0.0;
    for ( unsigned i = _begin; i <= _end; i++ ) {
        _Wspr += sprForc( i );
    }

	//Update spring forces on boundary nodes
	exchangeSprForc();

	if (_allowPlateauEnd) {		//if an early program termination due to a plateauing of cohesive energy is allowed
		if(_myid == 0) {	
			//Update and store plateau-locating data
			if (_Nt % 100 == 0) {		//discrete/martin's method of plateau location; every 100
				_Wcoh100[0] = _Wcoh[0];
			}
			_dWcoh[2] =  _dWcoh[0];		//continuous/andy's method of plateau location; every 1
			_dWcoh[1] = _Wcoh[0];
		}
		MPI::COMM_WORLD.Barrier();
		MPI::COMM_WORLD.Bcast( &_Wcoh100[0], 1, MPI::INT, 0);
		MPI::COMM_WORLD.Bcast( &_dWcoh[1], 2, MPI::INT, 0);
	}

    // Build the cohesive force vector, and cohesive-link energy values
    _Wcoh[0] = 0.0;
    _Wcoh[1] = 0.0;

	//if defectRange exists, must update sequentially to be consistent with serial case (assume this is necessary)
	if (_defectRange > 0) {		//if there is a zone around each fracture site that prevents other nodes from opening, non-zero
		for (unsigned j = 0; j < _numprocs; ++j) {
			int size;
			int begin;
			if (j == _myid) {
				size = _end - _begin + 1;
				begin = _begin;
				for ( unsigned i = _begin; i <= _end; i++ ) {
					std::vector<double> wCoh = cohForc( i );
					_Wcoh[0] += wCoh[0];
					_Wcoh[1] += wCoh[1];
				}
			}

			std::vector<int> local_ActivCoh = _ActivCoh;
			MPI::COMM_WORLD.Allreduce( &_ActivCoh[0], &local_ActivCoh[0], _Nx, MPI::INT, MPI_SUM);
			MPI::COMM_WORLD.Barrier();
		}
	} else {
		for ( unsigned i = _begin; i <= _end; i++ ) {
			std::vector<double> wCoh = cohForc( i );
			_Wcoh[0] += wCoh[0];
			_Wcoh[1] += wCoh[1];
		}

		std::vector<int> local_ActivCoh = _ActivCoh;
		MPI::COMM_WORLD.Allreduce( &_ActivCoh[0], &local_ActivCoh[0], _Nx, MPI::INT, MPI_SUM);
		MPI::COMM_WORLD.Barrier();
	}

	vector<double> wcohlocal(2);
	MPI::COMM_WORLD.Allreduce ( &_Wcoh[0], &wcohlocal[0], 2, MPI::DOUBLE, MPI_SUM);
	_Wcoh[0] = wcohlocal[0]; _Wcoh[1] = wcohlocal[1];

    //Calculate moving averages for plateau location, continuously
	if (_allowPlateauEnd) {
		if(_myid == 0) {	
			double ratio = 0.9995;
			_dWcoh[0] = _dWcoh[0] * ratio + (1 - ratio) * (_Wcoh[0] - _dWcoh[1]) / _Dt;	//new ema of deriv value
			_dWcoh[3] = (_dWcoh[0] - _dWcoh[2]) / _Dt;					//derive of ema ... value
			if ((_dWcoh[4] == 0.0) && (_dWcoh[3] < 0)) {
				_dWcoh[4] = _T;					//set time deriv if ema goes negative
			} else if ((_dWcoh[4] != 0.0) && (_dWcoh[3] > 0)) {
				_dWcoh[4] = 0.0; 				//reset time if deriv of ema goes positive
			} else if ((_dWcoh[4] != 0.0) && (_T > 2.0 * _dWcoh[4])) {
				FILE * pFile;
				pFile = fopen ( _logPath.c_str(), "a" );
				fprintf( pFile, "####    t = %12.3e  - Plastic Cohesive Energy has plateaued, no further fragmentation expected\n", _T );
				fclose( pFile );
				std::cout << "-------------------------------------------------------" << std::endl;
				std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
				std::cout << "t = " << _T << "  - Plastic Cohesive Energy has plateaued, no further fragmentation expected" << std::endl;
				std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
				std::cout << "-------------------------------------------------------" << std::endl;
				_stopFlag = true; 				//stop based on d(EMA(d(Wcoh))), after 2x
			}

			//Calculate moving averages for plateau location, discretely	
			//AJS 2/12/2013 -- NOTE!: This only calculates every 100 time-steps,
			//	so for smaller problems, _Wcoh100[2] is never updated, the column
			//	of data is all zero and gnuplot won't plot it!

			if (_Nt % 100 == 0) {
				double old = _Wcoh100[2];
				_Wcoh100[2] = _Wcoh100[2] * 0.9 + 0.1 * (_Wcoh[0] - _Wcoh100[0])/(_T - _Wcoh100[1]); //new ema value 
				_Wcoh100[1] = _T;
				if ((_Wcoh100[2] - old < 0) && (_Wcoh100[3] == 0)) {
					_Wcoh100[3] = _T;				//set time deriv if ema goes negative
				} else if ((_Wcoh100[3] != 0.0) && (_Wcoh100[2] - old > 0)) {
					_Wcoh100[3] = 0.0;				//reset time if deriv of ema goes positive
			 	} else if ((_dWcoh[4] != 0.0) && (_T > 3.0 * _dWcoh[4])) {
				   // _stopFlag = true;			//stop based on d(EMA(tangents(Wcoh))),after 3x
				}
			}
		}

		MPI::COMM_WORLD.Bcast( &_stopFlag, 1, MPI::BOOL, 0);
	}

    //Adjust for constant  strain rate --calculate _VelForcReq needed to maintain const SR
    if ( _ConstSRFlag == 1 ) {
        for ( unsigned i = 0; i < _NodPos.size(); i++) {
			if (!_local[i]) continue;
		    calcVelForc(i);
        }
    }


    // Build the external force vector, energy & Solve the system

    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
		if (!_local[i]) continue;

        // Compute the external energy
        _Wext += extForc( i );

        // Solve the problem
        _Acc[i][1][0] = ( _Fext[i][1][0] + _Fspr[i][0] + _Fcoh[i][0] ) / _m;
        _Acc[i][1][1] = ( _Fext[i][1][1] + _Fspr[i][1] + _Fcoh[i][1] ) / _m;
    }
}

void CartRing::NewmarkCorr () {

    //Compute kinetic energy
    _Wkin = 0.0;
    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
		if (!_local[i]) continue;

        // Update velocities
        /* SHOULD ACCOUNT FOR BOUNDARY CONDITIONS */
        _Vel[i][2][0] = _Vel[i][1][0] + 0.5 * _Dt * _Acc[i][1][0];
        _Vel[i][2][1] = _Vel[i][1][1] + 0.5 * _Dt * _Acc[i][1][1];

        // Compute the kinematic energy
        _Wkin += 0.5 * _m * ( pow( _Vel[i][2][0], 2 ) + pow( _Vel[i][2][1], 2 ) );
 
        // Displacements
        _Dis[i][2][0] = _Dis[i][1][0];
        _Dis[i][2][1] = _Dis[i][1][1];
    }
}

double CartRing::sprForc ( const unsigned sprNum ) {

    // Compute the stress
    _Stress[sprNum] = stress( sprNum );

    // Compute the axial force in the truss in the corotational frame
    double axiForc = _A * _Stress[sprNum];

    // Compute the spring element vector
    std::vector<double> elmVec = sprVecPred ( sprNum );
    double elmLength = sqrt( pow( elmVec[0], 2 ) + pow( elmVec[1], 2 ) );

    // Compute the nodal internal force in the cartesian frame
    _Fspr[_SprCon[sprNum].first ][0] =        axiForc * elmVec[0] / elmLength;
    _Fspr[_SprCon[sprNum].first ][1] =        axiForc * elmVec[1] / elmLength;
    _Fspr[_SprCon[sprNum].second][0] = -1.0 * axiForc * elmVec[0] / elmLength;
    _Fspr[_SprCon[sprNum].second][1] = -1.0 * axiForc * elmVec[1] / elmLength;
    // Compute the element strain
    double strain = ( pow( elmLength, 2 ) - pow( _Dx, 2 ) )
                  / ( _Dx * ( elmLength + _Dx ) );

    //Compute the average of the strengths of the surrounding cohesive links
	//for use as spring "yield strength" value
    double sigY = 0.5 * _SigC[sprNum] + 0.5 * _SigC[ (sprNum - 1 + _Nx) % _Nx];

    //Compute dissipated spring energy
    _WsprD += 0.5 * _A * _Dx * pow( sigY, 2 ) / _E * ( _sprDamage[sprNum] / (1 - _sprDamage[sprNum] ) );

    //Return elastic spring energy
    return  0.5 * _A * _Dx * strain * _Stress[sprNum];
}

std::vector<double> CartRing::cohForc ( const unsigned cohNum ) {

    // Find out the nodes connected to cohNum link
    unsigned nod_1 = _CohCon[cohNum].first;
    unsigned nod_2 = _CohCon[cohNum].second;

	//ensure that these are owned by the this processor
	assert(_local[nod_1] && _local[nod_2]);

	//ensure that these are owned by the same processor
	assert(_owner[nod_1] == _owner[nod_2]);

    //Create and assign variable that indicates if this link is open or closed
	//false = closed, true = open
    bool cohMod = ( _ActivCoh.size() == _CohCon.size() )
                ? _ActivCoh[cohNum] : false;

    std::vector<double> wCoh(2);
    // Compute the cohesive force
    if ( cohMod == false ) {
	//If closed...
	//cohesive force is an average of spring forces of surrounding elements
        _Fcoh[nod_1][0] = -0.5 * ( _Fspr[nod_1][0] - _Fspr[nod_2][0] );
        _Fcoh[nod_1][1] = -0.5 * ( _Fspr[nod_1][1] - _Fspr[nod_2][1] );
        _Fcoh[nod_2][0] = -0.5 * ( _Fspr[nod_2][0] - _Fspr[nod_1][0] );
        _Fcoh[nod_2][1] = -0.5 * ( _Fspr[nod_2][1] - _Fspr[nod_1][1] );

        // Test the value of the cohesive stress
        if ( _SigC.size() == _Nx ) {
			_sigCoh[cohNum] = 0;
		    _sigCoh[cohNum] = cosThetaPred( nod_1 ) * _Fcoh[nod_1][1] / _A
		        			- sinThetaPred( nod_1 ) * _Fcoh[nod_1][0] / _A;
	
			//Detect if this cohesive link is within the restricted zone of another,
			//already open link
			bool defectRangeFlag = false;	//Assume it is not
			if (_defectRange > 0) {
				//Convert the range into number of links
				int d_num = (int)floor( _defectRange * (double)(_Nx) / _L) ;
		      	for (int i = -d_num; i <= d_num; i++) {
					//Create link number that is checked against
		            int j = ( i + (int)(cohNum) + _Nx) % _Nx;
					if (_ActivCoh[j] == true) { 
						defectRangeFlag = true;		//true if link is open
					}

			    }
			}
			//Allow link to open if all other links in range are closed, & stress>strength
		    if ( ( _sigCoh[cohNum] > _SigC[cohNum] ) && (defectRangeFlag == false) ) {
		    	_ActivCoh[cohNum] = true;
				//Limit stress to maximum value(strength) for this one time-step
		        _Fcoh[nod_1][0] = -1.0 * _A * _SigC[cohNum] 
		                            * sinThetaPred( nod_1 );
		        _Fcoh[nod_1][1] = _A * _SigC[cohNum] * cosThetaPred( nod_1 );
		        _Fcoh[nod_2][0] = _A * _SigC[cohNum] * sinThetaPred( nod_2 );
		        _Fcoh[nod_2][1] = -1.0 * _A * _SigC[cohNum]
		                            * cosThetaPred( nod_2 );
		    }
        }

    } else {
	//If open...
        // Compute crack opening distance
        std::vector<double> crack = cohVecPred( cohNum );

	//Determine unit vector to midpoint of the cohesive link
	double xAvg = 0.5 * (cosThetaPred( _CohCon[cohNum].first ) + cosThetaPred( _CohCon[cohNum].second ));
	double yAvg = 0.5 * (sinThetaPred( _CohCon[cohNum].first ) + sinThetaPred( _CohCon[cohNum].second ));

	//Assign delta as the cross-product of the crack location vector 
		//and the crack opening (cohesive link) vector; delta in theta-dir only
	//_delta[cohNum] = 0;
       // _delta[cohNum] = sqrt( pow( crack[0], 2 ) + pow( crack[1], 2 ) );
	_delta[cohNum] = crack[1] * xAvg - crack[0] * yAvg;	

	//Assign damage as ratio of delta to maximum separation
	//Store _D[][] as the maxiumum damage
        double dammage = _delta[cohNum] / _DelC[cohNum];
        if ( dammage > 1.0 || _D[cohNum][0] >= 1 ) {
            _D[cohNum][1] = 1.0;
        } else {
            _D[cohNum][1] = ( dammage > _D[cohNum][0] ) ? dammage : _D[cohNum][0];
        }
	
        // Compute the cohesive traction
	_sigCoh[cohNum] = 0;
        cohStr( cohNum ); //assign _sigCoh

        // Compute the cohesive force and apply in the theta direction
	double cosPhi = -yAvg; //used to be -sinTheta(_CohCon[cohNum].first);
	double sinPhi = xAvg; //used to be cosTheta(_CohCon[cohNum].first);
        _Fcoh[nod_1][0] = _A * _sigCoh[cohNum] * cosPhi;
        _Fcoh[nod_1][1] = _A * _sigCoh[cohNum] * sinPhi;
        _Fcoh[nod_2][0] = -1.0 * _A * _sigCoh[cohNum] * cosPhi;
        _Fcoh[nod_2][1] = -1.0 * _A * _sigCoh[cohNum] * sinPhi;

        // Compute cohesive energy
        wCoh[1] = 0.5 * _A * _sigCoh[cohNum] * _delta[cohNum];
		if (_lawTyp.compare( 0 , 3, "LIN" ) == 0 ) { 
       		wCoh[0] = 0.5 * _A * _SigC[cohNum] * _D[cohNum][1] * _DelC[cohNum];
		}
		else if (_lawTyp.compare( 0 , 4, "SQRT" ) == 0 ) {
	        wCoh[0] = _A * _SigC[cohNum] * _D[cohNum][1] * _DelC[cohNum] * (0.5 - 1.0/6.0 * sqrt(_D[cohNum][1]));
		}
		else {
			cout << "cohesive law " << _lawTyp << " not yet implemented!" << endl;
		}

    }
    return wCoh;
}

void CartRing::calcVelForc ( const unsigned i ) {

	assert(_local[i]);

    //Calculate force at nodes required to maintain constant strain rate
    double type = _ValVelBC[0]; 		//1 for radial, 2 for rotational
    double target = _ValVelBC[1];

    //Mechanism for disabling loading ONLY at locations with full fragments (DISABLED)
    bool ok = true;	//assume loading ok
    for (unsigned j = 0; j < _fragLoc.size(); j++) {
	if (_fragLoc[j] == (int)i) {
	    ok = false;	//disable if fragment at this link
	}
    }

    //If loading is acceptable...calculate it
    if ( _DSum == 0 /*&& ok*/) {			//Any damage cancels all loading
        if (type == 1) {
            //Radial
	    double past = _Vel[i][0][0] * cosTheta(i) + _Vel[i][0][1] * sinTheta(i);		//v_r at node
	    double current = _Vel[i][1][0] * cosThetaPred(i) + _Vel[i][1][1] * sinThetaPred(i);	//v_r at node
		
	    //Calculate difference between target velocity and past/expected velocity
		//multiplied by two to strengthen effect, no overshooting observed
	    double diff = (target - past * 0.5 - current * 0.5) * 2.00;	

	    //Calculate required additional force to get to target F = ma = m*dv/dt
	    _VelForcReq[i][0] = (diff / _Dt) * cosThetaPred(i) * _m;	//in e_r direction, dotp with e_r
	    _VelForcReq[i][1] = (diff / _Dt) * sinThetaPred(i) * _m;

        } else if (type == 2) {
            //Rotational
	    double past = -_Vel[i][0][0] * sinTheta(i) + _Vel[i][0][1] * cosTheta(i);	//v_th at node
	    double current = -_Vel[i][1][0] * sinThetaPred(i) + _Vel[i][1][1] * cosThetaPred(i);//v_th at node
	    double diff = (target - current * 0.5 - past * 0.5) * 2.0;		//see above
	    _VelForcReq[i][0] = (diff / _Dt) * _m * -sinThetaPred(i);		//in e_theta dir
	    _VelForcReq[i][1] = (diff / _Dt) * _m * cosThetaPred(i);		//crossp with e_r

        } else {
		    std::cout << "Direction unknown!" << std::endl; 
        }
    } else {
	_VelForcReq[i][0] = 0;		//...else make sure it's zero
	_VelForcReq[i][1] = 0;
    }
}

double CartRing::extForc ( const unsigned nodNum ) {
	assert(_local[nodNum]);

    //reset values to zero
    _Fext[nodNum][1][0] = 0;
    _Fext[nodNum][1][1] = 0; 
    if ( _NodForcBC[0] == 1 ) {
        // Constant radial force
        _Fext[nodNum][1][0] = _ValForcBC[0] * cosThetaPred( nodNum );	//in e_r direction, dotp with e_r
        _Fext[nodNum][1][1] = _ValForcBC[0] * sinThetaPred( nodNum ); 
    }

    if ( _NodForcBC[0] == 2 ) {
        // Linear radial force (goal: constant velocity)
		cout << "*** NOT PROGRAMMED. CONSTANT STRAIN RATE ATTAINED BY CORRECTIVE LOADING" << endl;
		assert(1==0);
	//*** NOT PROGRAMMED. CONSTANT STRAIN RATE ATTAINED BY CORRECTIVE LOADING
	//	SEE applyVel(velDir,velVal) and calcVelFor(i)
    }

    if ( _NodForcBC[1] == 1 ) {
        // Torque
        double dist = sqrt( pow( _NodPos[nodNum][0] + _Dis[nodNum][1][0], 2 )		//expected position
                          + pow( _NodPos[nodNum][1] + _Dis[nodNum][1][1], 2 ) );
        _Fext[nodNum][1][0] = -1.0 * _ValForcBC[1] / dist	//M=rxF; F=M/r.
                            * sinThetaPred( nodNum );
        _Fext[nodNum][1][1] = _ValForcBC[1] / dist * cosThetaPred( nodNum ); //in e_theta dir,crossp with e_r
    }

    if (_ConstSRFlag == 1) {
	//Constant velocity / strain rate
	//Apply calculated correction loading from calcVelForc
	_Fext[nodNum][1][0] += _VelForcReq[nodNum][0];
        _Fext[nodNum][1][1] += _VelForcReq[nodNum][1];
	//Reset to zero
	_VelForcReq[nodNum][0] = 0;
	_VelForcReq[nodNum][1] = 0;
    }

    // Compute contribution to external energy of the node
    double wExt = _Vel[nodNum][1][0] * ( _Fext[nodNum][1][0] + _Fext[nodNum][0][0] )	//W = F*d = F*v*dt
                + _Vel[nodNum][1][1] * ( _Fext[nodNum][1][1] + _Fext[nodNum][0][1] );	//  = 0.5*(F1+F2)*v*dt
    return 0.5 * _Dt * wExt;
}

double CartRing::stress ( const unsigned sprNum ) {
    //Determine element stress
    // Compute a prediction of the element position vector
    std::vector<double> elmVec = sprVecPred( sprNum );

    // Compute the truss element / the spring current length
    double curLength = sqrt( pow( elmVec[0], 2 ) + pow( elmVec[1], 2 ) );

    // Compute the Crisfield version of the element strain - equivalent to engineering strain
    double strain = ( pow( curLength, 2 ) - pow( _Dx, 2 ) )
                  / ( _Dx * ( curLength + _Dx ) );

    //Compute Elastic Stress
    double Stress = _E * strain;

    //Allow decreased stiffness in zones where link opening is prohibited
    // Check to see if this element's links are in the range prohibited from opening
    if (_defectRange > 0) {
		bool defectRangeFlag = false;	//for one cohesive link
		bool defectRangeFlag2 = false;	//for the other
        int d_num = (int)floor( _defectRange * (double)(_Nx) / _L) ;	//convert the range to # of links
        for (int i = -d_num; i <= d_num; i++) {
            int j = ( i + (int)(sprNum) + _Nx) % _Nx;	//center the range at this element and check
			if (_ActivCoh[j] == true) { 
				defectRangeFlag = true;		//true if any links within range are open
			}
			int k = ( i + (int)(sprNum-1) + _Nx) % _Nx;
			if (_ActivCoh[k] == true) { 
				defectRangeFlag2 = true;		//true if any links within range are open
	    	}
		}
	
		//Non-hardening damage model; if both links are forced shut
		if ((defectRangeFlag == true) && (defectRangeFlag2 == true) && (strain > 0)) {
	
			//Determine average strength value of cohesive links ->yield strength of element
			double sigY = 0.5 * _SigC[sprNum] + 0.5 * _SigC[ (sprNum - 1 + _Nx) % _Nx];
	
			if (_sprDamage[sprNum] == 0.0) {
				//No previous damage
				if (strain <= sigY/_E) {
					//Unloading/reloading along E line (elastic)
					Stress = _E * strain;
					_sprDamage[sprNum] = 0;
				} else {
					//Along sigmaC line, updating damage (damaged)
					Stress = sigY;			//maximum stress allowed
					double E_Hat = sigY / strain;	//tangent line to new point
					_sprDamage[sprNum] = 1.0 - (E_Hat / _E);	//calculate damage
				}
			} else {
				//Previously damaged
				double strainD = sigY / (_E * (1 - _sprDamage[sprNum])); // max strain ever experienced
				if (strain <= strainD) {
					//Unloading/reloading along E_Hat line, no additional damage
					Stress = strain * _E * (1 - _sprDamage[sprNum]);
				} else {
					//Along sigmaC line, further damage
					Stress = sigY;
					double E_Hat = sigY / strain;
					_sprDamage[sprNum] = 1.0 - (E_Hat / _E);
				}
			}
		}
    }

    return Stress;
}

void CartRing::cohStr ( const unsigned cohNum ) {
	//this method contains the formula for the downward-sloping, linear cohesive zone law / traction-separation law
	//this method contains the formula for the square-root curve cohesive zone law / traction-separation law - Nicholas Moes TLS-based

    //Reset cohesive stress to zero
    _sigCoh[cohNum] = 0;
    if ( _delta[cohNum] > 0.0 ) {
        // Tensile behavior
        if ( (_delta[cohNum] > _DelC[cohNum]) || (_D[cohNum][0] >= 1.0 ) ) {
            // Fully broken link
            _sigCoh[cohNum] = 0.0;
        } else {
            // Partially damaged link

			if (_lawTyp.compare( 0 , 3, "LIN" ) == 0 ) { 
            		_sigCoh[cohNum] = _SigC[cohNum] * ( 1.0 - _D[cohNum][1] );
			}
			else if (_lawTyp.compare( 0 , 4, "SQRT" ) == 0 ) {
            		_sigCoh[cohNum] = _SigC[cohNum] * ( 1.0 - sqrt(_D[cohNum][1]) );
			}
			else {
				cout << "cohesive law " << _lawTyp << " not yet implemented!" << endl;
				assert(1==0);
			}

			if ( _delta[cohNum] < _D[cohNum][1] * _DelC[cohNum]) {
	            // Elastic unloading/reloading, no further damage
				_sigCoh[cohNum] *= _delta[cohNum] /( _D[cohNum][1] * _DelC[cohNum]);
			}

        }
    } else {
        // Compressive behavior ( Penalty )
        double pen = 1.0e+0;
		_sigCoh[cohNum] = _delta[cohNum] * _E / _Dx * pen;	//Follow scaled elastic modulus line*pen
    }

	return;
}

void CartRing::energBalance () {

	_WextT = 0;
	MPI::COMM_WORLD.Barrier(); 
	COMM_WORLD.Allreduce ( &_Wext, &_WextT, 1, MPI::DOUBLE, MPI_SUM);
	COMM_WORLD.Allreduce ( &_Wspr, &_Wspr, 1, MPI::DOUBLE, MPI_SUM);
	COMM_WORLD.Allreduce ( &_WsprD, &_WsprD, 1, MPI::DOUBLE, MPI_SUM);
	COMM_WORLD.Allreduce ( &_Wkin, &_Wkin, 1, MPI::DOUBLE, MPI_SUM);
	MPI::COMM_WORLD.Barrier();

	//Sum internal energies
	double Wint = _Wspr + _Wcoh[0] + _Wcoh[1] + _WsprD;
		
	//Determine maximum energy component
	_Wmax = ( Wint > _Wkin ) ? Wint : _Wkin;
	_Wmax = ( _Wmax > _WextT ) ? _Wmax : _WextT;

	//Sum total energies
	_Wsum = fabs(_Wkin + Wint - _WextT);
	
	if (_myid == 0) {
		//Check to see if too much energy is generated - NOTIFICATION @ 1%
		if ( _Wsum > 0.01 * _Wmax) {
		std::cout << "t = " << _T << "  - Energy Balance Violation: " << _Wsum << " > " << _Wmax * 0.01 << std::endl;
		FILE * pFile;
			pFile = fopen ( _logPath.c_str(), "a" );
			fprintf( pFile, "##    t = %12.3e  - Energy Balance Violation: %12.3e > %12.3e\n", _T, _Wsum, _Wmax * 0.01 );
			fclose( pFile );
		}
	}
	
	if (_checkEnergy) {
		//Check to see if too much energy is generated - CUT OFF @ 5%
		if (_Wsum > 0.05 * _Wmax) {
			if (_myid == 0) {
				FILE * pFile;
				pFile = fopen ( _logPath.c_str(), "a" );
				fprintf( pFile, "####    t = %12.3e  - Energy Generation Limit Exceeded (5%% Max) \n", _T );
				fclose( pFile );
				std::cout << "-------------------------------------------------------" << std::endl;
				std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
				std::cout << "t = " << _T << "  - Energy Generation Limit Exceeded (5% Max): " << _Wsum << " > " 
					<< _Wmax * 0.05 <<std::endl;
				std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
				std::cout << "-------------------------------------------------------" << std::endl;
			}
			_stopFlag = true;	//Politely terminates the program at the end of this solve loop
		}

		MPI::COMM_WORLD.Bcast( &_stopFlag, 1, MPI::BOOL, 0);
    	}
}

void CartRing::checkStable () {

    //Check to see if any cohesive link is in compression
    unsigned compression = 0;
    for (unsigned i = _begin; i <= _end; i++) {  
	if (_sigCoh[i] < 0 ) {
	    compression = 1;
	    _tFlag[1] = 1;	//enable one level of time-step refinement
	}
    }

    //Check to see if any link > 95% critical stress, or is within critical damage range
    //	meaning that its past the 95% mark and left of the scaled elastic modulus line
    unsigned temp = 0;
    for (unsigned i = _begin; i <= _end; i++ ){
	 	if ( ( (_delta[i] > 0 ) && ( _D[i][1] < (_sigCoh[i]) / (_E/_Dx) )) || _sigCoh[i] > 0.95 * _SigC[i]) {
			temp += 1; 		//count the number of links in this critical region
		}
    }
    
    //Activate an additional level of time-step refinement if any link is in critical zone
    if (temp == 0) {
		_tFlag[1] += 0;		//Keep level as is
    } else {
		_tFlag[1] += 1;		//Add one
    }
	
	unsigned valIn = _tFlag[1];
	unsigned valOut = 0;
	MPI::COMM_WORLD.Barrier(); COMM_WORLD.Allreduce ( &valIn, &valOut, 1, MPI::INT, MPI_MAX);
	_tFlag[1] = valOut;

}

void CartRing::fragCount () {

    //Count the number of broken cohesive links
    _fragLoc.resize(0);
    _numFrag = 0;
    _DSum = 0;

    for (unsigned i = _begin; i <= _end; i++ ){
		//Sum the total amount of damage to all links (analogous to WcohD)
		_DSum += (_D[i][1] >= 1) ? 1 : _D[i][1];

		//Check to see if fully broken
		if (_D[i][1] >= 1){
			_numFrag += 1;		//Add to fragment count
			_fragLoc.push_back(i);	//Add location to fragment location list
		}
    }

	exchangeFragInfo();

	if (_myid == 0) {
		//Find the length of each fragment
		if (_numFrag == 1){
			_fragLength.resize(1);
			_fragLength[0] = _Nx * _Dx;	//if only one break, length is whole circumference of ring
		} else {
			double nElems = 0;
			_fragLength.resize(_numFrag);
			for (unsigned k = 0; k < _fragLength.size(); k++){
				if (k == 0){
					//Length (# elems between) from last to first through theta=0=2pi
					nElems = fabs( _Nx - fabs( _fragLoc[0] - _fragLoc[_numFrag-1])); 
				} else {
					//Length (# elems between)
					nElems = fabs( _fragLoc[k - 1] - _fragLoc[k]);
				}
				//Convert number of elements to actual length
				_fragLength[k] = nElems * _Dx;
			}
		}

		//Initialize statistics of fragment length distribution
		_fMean = 0;
		_fMed = 0;
		_fMax = 0;
		_fMin = 0;
		_fStDev = 0;
		_fRange = 0;
		_fSkew = 0;
		_fExKurtosis = 0;

		//If there are any fragments...
		if (_numFrag > 0){
			//Calculate Median
			// Sort the list in ascending order
			sort(_fragLength.begin(), _fragLength.end());

			if (_numFrag % 2 == 0) {
				//If even number, take average of two middle values
				_fMed = ( _fragLength[ (unsigned)(_numFrag * 0.5) ]
					+ _fragLength[ (unsigned)(_numFrag * 0.5) -1 ] ) * 0.5;
			} else {
				//If odd number, take middle value
				_fMed = _fragLength[ (_numFrag - 1) / 2 ];
			}
			//Calculate Max, Min, Range
			_fMax = _fragLength.back();
			_fMin = _fragLength.front();
			_fRange = _fMax - _fMin;
	
			//Calculate Mean
			for (unsigned k = 0; k < _fragLength.size(); k++){
				//Sum of lengths
				_fMean += _fragLength[k];
			}
			//Mean = sum / number
			_fMean = _fMean / _numFrag;

			//Calculate Std. Deviation
			for (unsigned k = 0; k < _fragLength.size(); k++){
				//Sum of squared (lengths - means)
				_fStDev += pow( (_fragLength[k] - _fMean), 2);
			}
			_fStDev = sqrt( _fStDev / _numFrag ) ;

			//Calculate Skew
			for (unsigned k = 0; k < _fragLength.size(); k++){
				//Sum of squared (lengths - means)
				_fSkew += pow( (_fragLength[k] - _fMean), 3);
			}
			_fSkew = _fSkew / (_numFrag * pow(_fStDev,3) );

			//Calculate Kurtosis
			for (unsigned k = 0; k < _fragLength.size(); k++){
				//Sum of squared (lengths - means)
				_fExKurtosis += pow( (_fragLength[k] - _fMean), 4);
			}
			_fExKurtosis = _fExKurtosis / (_numFrag * pow(_fStDev,4) ) - 3.0;

		}
	}
}

void CartRing::timeStepRefine (const double refine) {
	//Initialization
	if (_Nt == 0) {
	    _deactive = 0;	//first-level refinement reduction multiplier
	    _deactive2 = 0;	//second-level refinement reduction multiplier
	}
/*
	//If there is a call for time-step refinement....
	if (_tFlag[1] != 0){	
	    if (_tFlag[0] == 0) {
		//If flag went from nothing to something
		std::cout << "Adaptive time-step initiated. t = " << _T << std::endl;
		_deactive = 0.0;
		_deactive2 = 0.0;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step initiated. t =  %e\n", _T );
    		fclose( pFile );
	    }    
	    if (_tFlag[1] == 2) {
		//If flag went from nothing to second level, second-level refinement
		_Dt = refine * refine * _Dt;
		_deactive = 0.0;
		_deactive2 = 0.0;
		if (_tFlag[0] != 2) {
		    std::cout << "Adaptive time-step refined. t = " << _T << std::endl;
		    FILE * pFile;
    		    pFile = fopen ( _logPath.c_str(), "a" );
    		    fprintf( pFile, "##    Adaptive time-step refined. t =  %e\n", _T );
    		    fclose( pFile );
		}
	    }
	    if ((_tFlag[1] == 1) && (_deactive2 == 0.0) && (_tFlag[0] != 2)) {
	    //If not doing second-level refinement, then do first-level refinement
	 	_Dt = refine * _Dt;
	    }
	}

	if (_tFlag[1] == 0){
	    //If flag went to zero...
	    if (_tFlag[0] == 1) {
		//If flag went from first level to zero
		std::cout << "Adaptive time-step released. t = " << _T << std::endl;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step released %e\n", _T );
    		fclose( pFile );
		//Signal demand to decrease first-level refinement
		_deactive = 1.0;
	    }
	    if (_tFlag[0] == 2) {
		//If flag went from second level to zero
		std::cout << "Adaptive time-step released. t = " << _T << std::endl;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step released. t =  %e\n", _T );
    		fclose( pFile );
		//Signal demand to decrease first-level refinement
		_deactive = 1.0;
		//Signal demand to decrease second-level refinement
		_deactive2 = 1.0;
	    }
	}

	if (_tFlag[1] == 1){
	    if (_tFlag[0] == 2) {	//If flag went from second level to first
		std::cout << "Adaptive time-step loosened. t = " << _T << std::endl;
		_deactive2 = 1.0;	//Signal demand to decrease second-level refinement
		_deactive = 0.0;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step loosened. t =  %e\n", _T );
    		fclose( pFile );
	    }
	}
	
	if (_deactive != 0.0 && _deactive2 == 0.0) {
	    //If doing first-level refinement reduction (1 -> 0)...
	    // Gradually relax the step linearly back to original over 5000 periods
	    _deactive = _deactive - 0.0002;
	    //Apply refinement
	    _Dt = _Dt * (1.0 + (refine - 1.0) * _deactive);
	    if (_deactive <= 0.0) {
		//If 1->0 reduction completed..
		std::cout << "Gradual relaxing 1 --> 0 completed. t = " << _T << std::endl;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Gradual relaxing 1 --> 0 completed. t =  %e\n", _T );
    		fclose( pFile );
		//Reset to zero, as to not trigger this loop again
		_deactive = 0.0;
	    }
	}
	if (_deactive2 != 0.0) {
	    //If doing second-level refinement reduction (2 -> 1)...
	    // Gradually relax the step linearly back to level one over 5000 periods
	    _deactive2 = _deactive2 - 0.0002;
	    //Apply refinement
	    _Dt = _Dt * refine * (1.0 + (refine - 1.0) * _deactive2);
	    if (_deactive2 <= 0.0 && _Nt != 0) {
		//If 2->1 reduction completed
		std::cout << "Gradual relaxing 2 --> 1 completed. t = " << _T << std::endl;
		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Gradual relaxing 2 --> 1 completed. t =  %e\n", _T );
    		fclose( pFile );
		//Reset to zero, as to not trigger this loop again
		_deactive2 = 0.0;
	    }
	}
*/

	if (_myid == 0) {

	double mult = 0.0;
	if (_tFlag[1] == 2 && _tFlag[0] == 2) {
	    _deactive = 0;
	    _deactive2 = 0;
	    mult = refine * refine;
	}
	if (_tFlag[1] == 1 && _tFlag[0] == 2) {
	    _deactive = 0;
	    _deactive2 = 1;
	}
	if (_tFlag[1] == 0 && _tFlag[0] == 2) {
	    _deactive = 1;
	    _deactive2 = 1;
	}
	if (_tFlag[1] == 2 && _tFlag[0] == 1) {
	    _deactive = 0;
	    _deactive2 = 0;
	    mult = refine * refine;
	}
	if (_tFlag[1] == 1 && _tFlag[0] == 1) {
	    _deactive = 0;
	    if (_deactive2 == 0) {
		mult = refine;
	    }
	}
	if (_tFlag[1] == 0 && _tFlag[0] == 1) {
	    _deactive = 1;
	}
	if (_tFlag[1] == 2 && _tFlag[0] == 0) {
	    _deactive = 0;
	    _deactive2 = 0;
	    mult = refine * refine;
	}
	if (_tFlag[1] == 1 && _tFlag[0] == 0) {
	    _deactive = 0;
	    if (_deactive2 == 0) {
		mult = refine;
	    }
	}
	if (_tFlag[1] == 0 && _tFlag[0] == 0) {
	    if (_deactive2 == 0) {
		if (_deactive == 0) {
		    mult = 1.0;
		}
	    } else {
		_deactive = 1.0;
	    }
	}

	if (_tFlag[1] != 0 && _tFlag[0] == 0) {
		std::cout << "Adaptive time-step initiated. t = " << _T << std::endl;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step initiated. t =  %e\n", _T );
    		fclose( pFile );
	}

	if (_tFlag[1] == 2 && _tFlag[0] != 2) {
	    std::cout << "Adaptive time-step refined. t = " << _T << std::endl;
	    FILE * pFile;
    	    pFile = fopen ( _logPath.c_str(), "a" );
    	    fprintf( pFile, "##    Adaptive time-step refined. t =  %e\n", _T );
    	    fclose( pFile );
	}

	if (_tFlag[1] != 2 && _tFlag[0] == 2) {
		std::cout << "Adaptive time-step loosened. t = " << _T << std::endl;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step loosened. t =  %e\n", _T );
    		fclose( pFile );
	}

	if (_tFlag[1] == 0 && _tFlag[0] != 0) {
		std::cout << "Adaptive time-step released. t = " << _T << std::endl;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step released. t =  %e\n", _T );
    		fclose( pFile );
	}

	if (_deactive2 == 0) {
	    if (_deactive == 0) {
		//Mult should be predefined.
	    } else {
			mult = 1 - (1 - refine) * _deactive;
			_deactive = _deactive - 0.0002;
			if (_deactive <= 0.0) {
				_deactive = 0.0;
				std::cout << "Gradual relaxing 1 --> 0 completed. t = " << _T << std::endl;
				FILE * pFile;
				pFile = fopen ( _logPath.c_str(), "a" );
				fprintf( pFile, "##    Gradual relaxing 1 --> 0 completed. t =  %e\n", _T );
				fclose( pFile );
			}
	    }
	} else {
	    mult = refine * (1 - (1 - refine) * _deactive2);
	    _deactive2 = _deactive2 - 0.0002;
	    if (_deactive2 <= 0.0) {
		_deactive2 = 0.0;
		std::cout << "Gradual relaxing 2 --> 1 completed. t = " << _T << std::endl;
		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Gradual relaxing 2 --> 1 completed. t =  %e\n", _T );
    		fclose( pFile );
	    }
	}
	
	if (mult == 0) {
	    std::cout << "Mult should have been defined by now" << std::endl;
	}
	_Dt = mult * _Dt;
	}

	MPI::COMM_WORLD.Bcast( &_Dt, 1, MPI::DOUBLE, 0);
	MPI::COMM_WORLD.Bcast( &_deactive, 1, MPI::DOUBLE, 0);
	MPI::COMM_WORLD.Bcast( &_deactive2, 1, MPI::DOUBLE, 0);

	/*Time Step Refinement Summary:
		CartRing::checkStable() evaluates the current position of all cohesive links
		in the cohesive law diagram. Levels of refinement are warranted for either or
		both of the two following cases: critical zone and compression. Critical zone
		means that one or more cohesive links is on the vertical axis at or above 95%
		of critical stress and left of the elastic modulus line. The elastic modulus
		line is the elastic modulus scaled by element length. When an element is 
		within this critical zone, one level of time step refinement is warranted.
		The second is compression. When any element has a cohesive stress less than
		zero, it is considered to be in compression, and warrants one level of time-
		step refinement. So, if there are compressive elements and critical-zone
		elements, the level of refinement is two. Either alone is one. None is none.

		A zero-level of time step refinement means that _Dt is just 0.8 times the
		critical time-step, _Dt_c. One level of refinement will multiply _Dt times an
		additional factor, 'refine'. When refinement is no longer called for, the
		refinement reduction multiplier of refine, '_deactive', will go linearly from
		one to zero over 5000 periods, linearly bringing the effective multiplier
		from 'refine' to 1. The second level of time-step refinement multiplies _Dt
		by 'refine' squared. Similarly, when only a single level is then required,
		_deactive2 varies from one to zero, bringing the effective multiplier from
		refine^2 to refine over	5000 steps. Going from a second level to zero 
		immediately will run through the _deactive2 sequence (2->1) and then the
		_deactive sequence (1->0) sequentially over a total of 10000 periods. */
}

void CartRing::update () {

    // Nodal positions, Kinematics & External forces 
    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
		if (!_local[i]) continue;
        for ( unsigned j = 0; j < 2; j++ ) {
            // Nodal positions
            _NodPos[i][j] += _Dis[i][2][j];
            // Kinematics
            _Dis[i][0][j]  = _Dis[i][2][j];
            _Vel[i][0][j]  = _Vel[i][2][j];
            _Acc[i][0][j]  = _Acc[i][1][j];
            // External forces
            _Fext[i][0][j] = _Fext[i][1][j];
        }
    }

    // Internal variables
    for ( unsigned i = _begin; i <= _end; i++ ) {
        _D[i][0] = _D[i][1];
    }
}

double CartRing::cosTheta ( const unsigned nodNum ) const {
    //Determine distance of nodal location
    double norm = sqrt( pow( _NodPos[nodNum][0], 2 )
                      + pow( _NodPos[nodNum][1], 2 ) );
    //Determine cosine of nodal location
    return _NodPos[nodNum][0] / norm;
}

double CartRing::cosThetaPred ( const unsigned nodNum ) const {
    //Determine expected distance of nodal location
    double X = _NodPos[nodNum][0] + _Dis[nodNum][1][0];
    double Y = _NodPos[nodNum][1] + _Dis[nodNum][1][1];
    double norm = sqrt( pow( X, 2 ) + pow( Y, 2 ) );
    //Determine expected cosine of nodal location
    return X / norm;
}

double CartRing::sinTheta ( const unsigned nodNum ) const {
    //Determine distance of nodal location
    double norm = sqrt( pow( _NodPos[nodNum][0], 2 )
                      + pow( _NodPos[nodNum][1], 2 ) );
    //Determine sine of nodal location
    return _NodPos[nodNum][1] / norm;
}

double CartRing::sinThetaPred ( const unsigned nodNum ) const {
    //Determine expected distance of nodal location
    double X = _NodPos[nodNum][0] + _Dis[nodNum][1][0];
    double Y = _NodPos[nodNum][1] + _Dis[nodNum][1][1];
    double norm = sqrt( pow( X, 2 ) + pow( Y, 2 ) );
    //Determine expected sine of nodal location
    return Y / norm;
}

std::vector<double> CartRing::sprVec ( const unsigned sprNum ) const {

    // Get the connectivity of the element sprNum
    unsigned nod_1 = _SprCon[sprNum].first;
    unsigned nod_2 = _SprCon[sprNum].second;

    //Calculate element length vector
    std::vector<double> elmVec (2);
    elmVec[0] = _NodPos[nod_2][0] - _NodPos[nod_1][0];
    elmVec[1] = _NodPos[nod_2][1] - _NodPos[nod_1][1];

    return elmVec;
}

std::vector<double> CartRing::sprVecPred ( const unsigned sprNum ) const {

    // Get the connectivity of the element sprNum
    unsigned nod_1 = _SprCon[sprNum].first;
    unsigned nod_2 = _SprCon[sprNum].second;

    //Calculate expected element length vector
    std::vector<double> elmVec (2);
    elmVec[0] = ( _NodPos[nod_2][0] + _Dis[nod_2][1][0] ) 
              - ( _NodPos[nod_1][0] + _Dis[nod_1][1][0] );
    elmVec[1] = ( _NodPos[nod_2][1] + _Dis[nod_2][1][1] ) 
              - ( _NodPos[nod_1][1] + _Dis[nod_1][1][1] );

    return elmVec;
}

std::vector<double> CartRing::cohVecPred ( const unsigned cohNum ) const {

    // Get the connectivity of the element cohNum
    unsigned nod_1 = _CohCon[cohNum].first;
    unsigned nod_2 = _CohCon[cohNum].second;

    //Calculate expected link length vector
    std::vector<double> elmVec (2);
    elmVec[0] = ( _NodPos[nod_2][0] + _Dis[nod_2][1][0] )
              - ( _NodPos[nod_1][0] + _Dis[nod_1][1][0] );
    elmVec[1] = ( _NodPos[nod_2][1] + _Dis[nod_2][1][1] )
              - ( _NodPos[nod_1][1] + _Dis[nod_1][1][1] );
    return elmVec;
}

void CartRing::defineBoundaryNodes() { 
	//create list of node to be sent, origin, and destination
	int size;
	if (_myid == 0) {
		for (unsigned sprNum = 0; sprNum < _Nx; ++sprNum) {
			// Get the connectivity of the element sprNum
			unsigned nod_1 = _SprCon[sprNum].first;
			unsigned nod_2 = _SprCon[sprNum].second;

			int owner1 = _owner[nod_1];
			int owner2 = _owner[nod_2];
	
			if (owner1 != owner2) {
				//cout << "sprVecPred:  " << "(" << sprNum << ") " << nod_1 << " - "  << owner1 << " || " << nod_2 << " - " << owner2 << endl;

				//owner 1 needs to send nod_1 to owner 2; owner 2 needs to send nod_2 to owner 1
				_nodeList.push_back(nod_1); _originList.push_back(owner1); _destList.push_back(owner2); //_dirList.push_back(1);
				//_nodeList.push_back(nod_2); _originList.push_back(owner2); _destList.push_back(owner1); _dirList.push_back(2);
			}
		}
		size = _nodeList.size();
	}

	MPI::COMM_WORLD.Barrier();
	//broadcast sizes and resize vectors
	MPI::COMM_WORLD.Bcast( &size, 1, MPI::INT, 0);
	_nodeList.resize(size); _originList.resize(size); _destList.resize(size);// _dirList.resize(size);		

	//broadcast boundary nodes to be exchanged	
	MPI::COMM_WORLD.Barrier();
	MPI::COMM_WORLD.Bcast( &_nodeList[0], _nodeList.size(), MPI::INT, 0);
	MPI::COMM_WORLD.Bcast( &_originList[0], _nodeList.size(), MPI::INT, 0);
	MPI::COMM_WORLD.Bcast( &_destList[0], _nodeList.size(), MPI::INT, 0);
	//MPI::COMM_WORLD.Bcast( &_dirList[0], _nodeList.size(), MPI::INT, 0);
	MPI::COMM_WORLD.Barrier();
}

void CartRing::exchangeBoundaryNodes () { 
	//use direction one to pull spring nodes in from neighboring elements
	//send all nodes
	for (unsigned i = 0; i < _nodeList.size(); ++i) {
		int tag = i*2;
		if (_myid == _originList[i] /*&& _dirList[i] == 1*/) {
			COMM_WORLD.Send(&_NodPos[_nodeList[i]][0], 2, MPI::DOUBLE, _destList[i], tag);
			COMM_WORLD.Send(&_Dis[_nodeList[i]][1][0], 2, MPI::DOUBLE, _destList[i], tag+1);
			//cout << "disp: sent node " << _nodeList[i] << " from " << _originList[i] << " to " << _destList[i] << endl;
		}
	}

	MPI::COMM_WORLD.Barrier();

	//receive all nodes
	for (unsigned i = 0; i < _nodeList.size(); ++i) {
		int tag = i*2;
		if (_myid == _destList[i] /* && _dirList[i] == 1*/) {
			COMM_WORLD.Recv(&_NodPos[_nodeList[i]][0], 2, MPI::DOUBLE, _originList[i], tag);
			COMM_WORLD.Recv(&_Dis[_nodeList[i]][1][0], 2, MPI::DOUBLE, _originList[i], tag+1);
		}
	}

	MPI::COMM_WORLD.Barrier();

	return;
}

void CartRing::exchangeSprForc () {
	//use direction two to set spring nodes on neighboring elements' spring force	

	//send all nodes -- reverse direction
	for (unsigned i = 0; i < _nodeList.size(); ++i) {
		int tag = i;
		if (_myid == _destList[i] /*&& _dirList[i] == 1*/) {
			COMM_WORLD.Send(&_Fspr[_nodeList[i]][0], 2, MPI::DOUBLE, _originList[i], tag);
			//cout << "force: sent node " << _nodeList[i] << " from " << _destList[i] << " to " << _originList[i] << endl;
		}
	}

	MPI::COMM_WORLD.Barrier();

	//receive all nodes -- reverse direction
	for (unsigned i = 0; i < _nodeList.size(); ++i) {
		int tag = i;
		if (_myid == _originList[i]  /*&& _dirList[i] == 1*/) {
			COMM_WORLD.Recv(&_Fspr[_nodeList[i]][0], 2, MPI::DOUBLE, _destList[i], tag);
		}
	}

	MPI::COMM_WORLD.Barrier();



	return;
}

void CartRing::exchangeFragInfo() {

    int locNumFrag = _fragLoc.size();

    vector<int> numfrags(_numprocs);
    MPI::COMM_WORLD.Allgather(&locNumFrag, 1, MPI::INT, &numfrags[0], 1, MPI::INT);

    _numFrag = 0;
    for (unsigned i=0; i<_numprocs; i++) 
        _numFrag += numfrags[i];

    vector<int> outVector (_numFrag);
    int displ[_numprocs]; 

    if (_myid == 0) {
        double sum = 0;
        for (unsigned i = 0; i < _numprocs; ++i) {
            displ[i] = sum;
            sum += numfrags[i];
        }
    }

    MPI::COMM_WORLD.Gatherv(&_fragLoc[0], numfrags[_myid], MPI::INT, &outVector[0], &numfrags[0], &displ[0], MPI::INT,0);

	MPI::COMM_WORLD.Barrier();
	_fragLoc.resize(0); _fragLoc.resize(_numFrag);

	if (_myid == 0) {
		for (unsigned i = 0; i < _numFrag; ++i) 		_fragLoc[i] = outVector[i];
	}

	MPI::COMM_WORLD.Bcast( &_fragLoc[0], _numFrag, MPI::INT, 0);
	double valIn = _DSum;
	double valOut = 0.0;
	MPI::COMM_WORLD.Allreduce ( &valIn, &valOut, 1, MPI::DOUBLE, MPI_SUM);
	_DSum = valOut;

	return;
}


/*******************************************************************************

                M E T H O D S    T O     P R I N T     S T U F F

*******************************************************************************/

/*------------------------------- P U B L I C --------------------------------*/

void CartRing::plotAtNodes ( const std::vector<unsigned>& NodalIds ) {
	if (_myid == 0) {

		// Gnuplot file for radial velocity 
		FILE * pFileVr;
		std::string velRFile = _path+"/gnuplot/plotRadialVelo.plt";		//../results
		pFileVr = fopen( velRFile.c_str(), "w" );
		fprintf( pFileVr, "#!/usr/bin/gnuplot\n" );
		fprintf( pFileVr, "# GNUPLOT file generated by <cartRing.h>");
		fprintf( pFileVr, " -- MH[DCML] (2010)\n");
		fprintf( pFileVr, "# Radial velocities at prescribed nodes\n" );
		fprintf( pFileVr, "set xlabel \"time (s)\"\n" );
		fprintf( pFileVr, "set ylabel \"radial velocities (m/s)\"\n" );
		fprintf( pFileVr, "set terminal svg size 1200, 800\n\n" );
		fprintf( pFileVr, "set output './pngFiles/nodalRadialVelo.svg'\n");
		fprintf( pFileVr, "plot " );
		fclose( pFileVr );

		// Gnuplot file for circumferential velocity 
		FILE * pFileVt;
		std::string velTFile = _path+"/gnuplot/plotCircumVelo.plt";		//../results
		pFileVt = fopen( velTFile.c_str(), "w" );
		fprintf( pFileVt, "#!/usr/bin/gnuplot\n" );
		fprintf( pFileVt, "# GNUPLOT file generated by <cartRing.h>");
		fprintf( pFileVt, " -- MH[DCML] (2010)\n");
		fprintf( pFileVt, "# Circumferential velocities at prescribed nodes\n" );
		fprintf( pFileVt, "set xlabel \"time (s)\"\n" );
		fprintf( pFileVt, "set ylabel \"circumferential velocities (m/s)\"\n" );
		fprintf( pFileVt, "set terminal svg size 1200, 800\n\n" );
		fprintf( pFileVt, "set output './pngFiles/nodalCircumVelo.svg'\n");
		fprintf( pFileVt, "plot " );
		fclose( pFileVt );

		_NodesToPlot.resize( NodalIds.size() );
		_NodeFiles.resize( NodalIds.size() );
		for ( unsigned i = 0; i < _NodesToPlot.size(); i++ ) {
		    _NodesToPlot[i] = NodalIds[i];
		    std::string nodalId = convertInt( NodalIds[i] );
		    _NodeFiles[i] = _path+"/datFiles/node_" + nodalId + ".dat";	//../results
		    // Prepare Gnuplot data file
		    FILE * pFile;
		    pFile = fopen( _NodeFiles[i].c_str(), "w" );
		    fprintf( pFile, "# GNUPLOT file generated by <cartRing.h>" );
		    fprintf( pFile, " -- MH [DCML] (2010)\n" );
		    fprintf( pFile, "# Nodal quantities for node: %s\n", nodalId.c_str() );
		    fprintf( pFile, "#       time          vr          vt\n" );
		    fclose( pFile );
		    // Complete velocity file
		    std::string nodFil = "./datFiles/node_" + nodalId + ".dat";		//.
		    pFileVr = fopen( velRFile.c_str(), "a" );
		    fprintf( pFileVr, "\"%s\" usi 1:2 ti \"vr_%s\" w l",
		             nodFil.c_str(), nodalId.c_str() );
		    if ( i != _NodesToPlot.size()-1 ) {
		        fprintf( pFileVr, ",\\\n     " );
		    }
		    fclose( pFileVr );
		    pFileVt = fopen( velTFile.c_str(), "a" );
		    fprintf( pFileVt, "     \"%s\" usi 1:3 ti \"vt_%s\" w l ",
		             nodFil.c_str(), nodalId.c_str() );
		    if ( i != _NodesToPlot.size()-1 ) {
		        fprintf( pFileVt, ",\\\n     " );
		    }
		    fclose( pFileVt );
		}
	} else {
		_NodesToPlot.resize( NodalIds.size() );
		_NodeFiles.resize( NodalIds.size() );
		for ( unsigned i = 0; i < _NodesToPlot.size(); i++ ) {
		    _NodesToPlot[i] = NodalIds[i];
		    std::string nodalId = convertInt( NodalIds[i] );
		    _NodeFiles[i] = _path+"/datFiles/node_" + nodalId + ".dat";	//../results
		}
	}
	return;

}

void CartRing::plotAtElms ( const std::vector<unsigned>& ElmIds ) {
	if (_myid == 0) {

		// Gnuplot file for stresses
		FILE * pFileS;
		std::string stressFile = _path+"/gnuplot/plotStre.plt";	//../results
		pFileS = fopen( stressFile.c_str(), "w" );
		fprintf( pFileS, "#!/usr/bin/gnuplot\n" );
		fprintf( pFileS, "# GNUPLOT file generated by <cartRing.h>");
		fprintf( pFileS, " -- MH[DCML] (2010)\n");
		fprintf( pFileS, "# Stresses at prescribed elements\n" );
		fprintf( pFileS, "set xlabel \"time (s)\"\n" );
		fprintf( pFileS, "set ylabel \"stress (Pa)\"\n" );
		fprintf( pFileS, "set terminal svg size 1200, 800\n\n" );
		fprintf( pFileS, "set output './pngFiles/elmStress.svg'\n");
		fprintf( pFileS, "plot " );
		fclose( pFileS );

		_ElmsToPlot.resize( ElmIds.size() );
		_ElmFiles.resize( ElmIds.size() );
		for ( unsigned i = 0; i < _ElmsToPlot.size(); i++ ) {
		    _ElmsToPlot[i] = ElmIds[i];
		    std::string elmId = convertInt( ElmIds[i] );
		    _ElmFiles[i] = _path+"/datFiles/elem_" + elmId + ".dat";	//../results
		    // Prepare Gnuplot data file
		    FILE * pFile;
		    pFile = fopen( _ElmFiles[i].c_str(), "w" );
		    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
		    fprintf( pFile, " -- MH [DCML] (2010)\n" );
		    fprintf( pFile, "# Elm quantities for node: %s\n", elmId.c_str() );
		    fprintf( pFile, "#       time          st\n" );
		    fclose( pFile );
		    // Complete stress file
		    std::string elmFil = "./datFiles/elem_" + elmId + ".dat";		//.
		    pFileS = fopen( stressFile.c_str(), "a" );
		    fprintf( pFileS, "\"%s\" usi 1:2 ti \"st_%s\" w l ",
		             elmFil.c_str(), elmId.c_str() );
		    if ( i != _ElmsToPlot.size()-1 ) {
		        fprintf( pFileS, ",\\\n     " );
		    }
		    fclose( pFileS );
		}
	} else {
		_ElmsToPlot.resize( ElmIds.size() );
		_ElmFiles.resize( ElmIds.size() );
		for ( unsigned i = 0; i < _ElmsToPlot.size(); i++ ) {
		    _ElmsToPlot[i] = ElmIds[i];
		    std::string elmId = convertInt( ElmIds[i] );
		    _ElmFiles[i] = _path+"/datFiles/elem_" + elmId + ".dat";	//../results
		}
	}
}

void CartRing::plotEnergies () {
	if (_myid > 0) return;

    // Gnuplot file for energies
    FILE * pFileW;
    std::string stressFile = _path+"/gnuplot/plotEnrg.plt";		//../results
    pFileW = fopen( stressFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <cartRing.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Global energies\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"energy (J)\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgSpr.svg'\n");
    if (_defectRange == -1.0) {			//not sure why this is here
		fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'Wspr' w l\n" );
    } else {
		fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'WsprE' w l ,\\\n" );
		fprintf( pFileW, "     './datFiles/energies.dat' usi 1:14 ti 'WsprD' w l\n" );
    }
    fprintf( pFileW, "set output './pngFiles/enrgCoh.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:3 ti 'WcoD' w l ,\\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:4 ti 'WcoE' w l\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgExt.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:5 ti 'Wext' w l\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgKin.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:6 ti 'Wkin' w l\n\n" );
    fprintf( pFileW, "set ylabel \"Energy Balance Check\"\n" );
    fprintf( pFileW, "set output './pngFiles/enrgBalance.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:8 ti 'Wsum' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:7 ti '0.01 * Wmax' w l\n\n" );
    fprintf( pFileW, "set ylabel \"J/s\"\n" );
    fprintf( pFileW, "set output './pngFiles/enrgdWcoh.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:11 ti 'EMA(dWcoh)' w l\n\n" );
    fprintf( pFileW, "set ylabel \"J/s2\"\n" );
    fprintf( pFileW, "set output './pngFiles/enrgd2Wcoh.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:12 ti 'd(EMA(dWcoh))' w l\n\n" );
    fprintf( pFileW, "set logscale y\n" );
    fprintf( pFileW, "set ylabel \"J/s\"\n" );
    fprintf( pFileW, "set output './pngFiles/enrgdWcoh100.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:13 ti 'dWcoh100' w l\n\n" );
    fclose( pFileW );

    // Prepare Gnuplot data file
    _EnrgFile = _path+"/datFiles/energies.dat";		//../results
    FILE * pFile;
    pFile = fopen( _EnrgFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Total energies for the system\n" );
    fprintf( pFile, "#       time       WsprE       WcohD       WcohE");
    fprintf( pFile, "        Wext        Wkin   0.01*Wmax        Wsum" );
    fprintf( pFile, "       tFlag      refine  EMA(dWcoh) d(EMA(dWcoh" );
    fprintf( pFile, "))  dWcoh100       WsprD\n" );
    fclose( pFile );
}

void CartRing::plotCohLaw (const std::vector<unsigned>& cohNums){

	// Prepare Gnuplot data file
	if (_numprocs == 1) {
		_CohLawFile = _path+"/datFiles/cohLaw.dat";		//../results
	} else {
		_CohLawFile = _path+"/datFiles/cohLaw_" + convertInt(_myid) + ".dat";		//../results
	}	

	if (_myid == 0) {

		_cLaw.resize( cohNums.size() );
		for (unsigned i = 0; i < cohNums.size(); i++){
			_cLaw[i] = cohNums[i];
		}
		// Gnuplot file for cohesive link information
		FILE * pFileW;
		std::string cohFile = _path+"/gnuplot/plotCohLaw.plt";		//../results
		pFileW = fopen( cohFile.c_str(), "w" );
		fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
		fprintf( pFileW, "# GNUPLOT file generated by <cartRing.h>");
		fprintf( pFileW, " -- MH[DCML] (2010)\n");
		fprintf( pFileW, "# Cohesive Law\n" );
		fprintf( pFileW, "set xlabel \"crack opening (m)\"\n" );
		fprintf( pFileW, "set ylabel \"traction (Pa)\"\n" );
		fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );

		for (unsigned i = 0; i < _cLaw.size(); i++) {
			if (_lawTyp.compare( 0 , 3, "LIN" ) == 0 ) { 
            		fprintf( pFileW, "s1(x) = %12.3e * ( 1.0 - x/%12.3e);\n", _SigC[ _cLaw[i] ], _DelC[ _cLaw[i] ] );
			}
			else if (_lawTyp.compare( 0 , 4, "SQRT" ) == 0 ) {
            		fprintf( pFileW, "s1(x) = %12.3e * ( 1.0 - sqrt(x/%12.3e));\n", _SigC[ _cLaw[i] ], _DelC[ _cLaw[i] ] );
			}
			else {
				cout << "cohesive law " << _lawTyp << " not yet implemented!" << endl;
			}

		    fprintf( pFileW, "s(x) = ( x < %12.3e ? s1(x) : 0.0 );\n\n",  _DelC[ _cLaw[i] ] );
		    fprintf( pFileW, "e(x) = x * %12.3e / %12.3e;\n\n",  _E, _Dx );
		    fprintf( pFileW, "set output \"./pngFiles/CohLaw%u.svg\"\n", i + 1);
		    fprintf( pFileW, "set yrange [:%12.3e]\n", _SigC[ _cLaw[i] ]);
		    fprintf( pFileW, "plot s(x) ti 'analytical %u' w l lw 3 , \\\n", _cLaw[i] );
		    fprintf( pFileW, "    './datFiles/cohLaw.dat' usi %u:%u ti 'computed %u' w lp ,\\\n", i*2+2, 2*i+3, _cLaw[i] );
			fprintf( pFileW, "    e(x) ti 'Elastic Modulus' w l lw 3 ;\n\n");
		}
		fclose( pFileW );

		FILE * pFile;
		pFile = fopen( _CohLawFile.c_str(), "w" );
		fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
		fprintf( pFile, " -- MH [DCML] (2010)\n" );
		fprintf( pFile, "# Cohesive Link Information for selected links:");
		for (unsigned i = 0; i < _cLaw.size(); i++) {
		    fprintf( pFile, " %u", _cLaw[i]);
		}    
		fprintf( pFile, "\n");
		fprintf( pFile, "#       time");
		for (unsigned i = 0; i < _cLaw.size(); i++) {
		    fprintf( pFile, "    delta%u    sigma%u", _cLaw[i], _cLaw[i] );
		} 
		fprintf( pFile, "\n");
		fclose( pFile );
	} else {
		_cLaw.resize( cohNums.size() );
		for (unsigned i = 0; i < cohNums.size(); i++){
			_cLaw[i] = cohNums[i];
		}
	}
	return;
}

void CartRing::plotFrags (){

	if (_myid > 0) return;

    // Gnuplot file for fragmentation
    FILE * pFileW;
    std::string fragFile = _path+"/gnuplot/plotFragInfo.plt";		//../results
    pFileW = fopen( fragFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <cartRing.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Fragmentation Information\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"Number of Fragments\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/numFrag.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraginfo.dat' usi 1:3 ti 'Sum of Damage' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/fraginfo.dat' usi 1:2 ti '# Frags' w l\n\n" );


    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"stress (Pa)\"\n" );
    fprintf( pFileW, "set output './pngFiles/SigL_R_C.svg'\n");
    fprintf( pFileW, " plot './datFiles/fraginfo.dat' usi 1:10 ti 'SigL'w l,\\\n");
    fprintf( pFileW, "             './datFiles/fraginfo.dat' usi 1:11 ti 'SigR' w l,\\\n");
    fprintf( pFileW, "             './datFiles/fraginfo.dat' usi 1:13 ti 'SigC' w l\n\n");


    fprintf( pFileW, "set logscale y\n" );		//Time-step graph
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"_Dt\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/dt.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:10 ti 'Refinement' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:9 ti 'Time Step Flag' w l\n\n" );

    fclose( pFileW );

    // Prepare Gnuplot data file
    _FragFile = _path+"/datFiles/fraginfo.dat";		//../results
    FILE * pFile;
    pFile = fopen( _FragFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#       time      #frags   DamageSum        Mean      Median         Max         Min");
    fprintf( pFile, "       StDev       Range        Skew    Ex. Kurt.       SigL        SigR      SigL*R        SigC");
    fprintf( pFile, "((R*L^2)/|L|) (Locations)\n");
    fclose( pFile );
}

void CartRing::plotHisto () {
	if (_myid > 0) return;

    // Gnuplot file for fragmentation histogram
    FILE * pFileW;
    std::string histoFile = _path+"/gnuplot/plotHisto.plt";		//../results
    pFileW = fopen( histoFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <cartRing.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "set title \"Fragment Length CDF Graph\"\n"); 
    fprintf( pFileW, "set xlabel \"Fragment Length, Lf (m)\"\n" );
    fprintf( pFileW, "set ylabel \"# ( Length > Lf )\"\n" );
    fprintf( pFileW, "set yrange [0:%u]\n", _numFrag);
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/fraginvcdf.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' usi 1:2 ti '' w l;\n\n" );
    fprintf( pFileW, "set boxwidth 0.9 absolute\n" );
    fprintf( pFileW, "set style fill   solid 1.00 border -1\n" );
    fprintf( pFileW, "set title \"Fragmentation Histogram\"\n"); 
    fprintf( pFileW, "set xlabel \"Size Distribution Relative to Max. Frag. Size (Percent)\"\n" );
    fprintf( pFileW, "set ylabel \"Frequency\"\n" );
    fprintf( pFileW, "set xrange [0:100]\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/fragHisto.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' using 3:4:(4) ti '' with boxes;\n" );
    fclose( pFileW );

    // Prepare Gnuplot data file
    _HistoFile = _path+"/datFiles/fraghisto.dat";		//../results
    FILE * pFile;
    pFile = fopen( _HistoFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#Length, Lf   # With Length > Lf   Bin Center   Frequency\n" );
    fclose( pFile );
}

void CartRing::plotSTheta () {
	if (_myid == 0) {
		// Gnuplot file for fragmentation histogram
		FILE * pFileW;
		std::string sThetaFile = _path+"/gnuplot/plotSTheta.plt";	//../results/
		pFileW = fopen( sThetaFile.c_str(), "w" );
		fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
		fprintf( pFileW, "# GNUPLOT file generated by <cartRing.h>");
		fprintf( pFileW, " -- MH[DCML] (2010)\n");
		fprintf( pFileW, "datafile = './datFiles/stresstheta.dat'\n");
		fprintf( pFileW, "stats datafile;\n");
		fprintf( pFileW, "set title \"Cohesive Link Stress vs. Theta Graph\"\n"); 
		fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
		fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
		fprintf( pFileW, "set xrange [0:360]\n");
		fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
		fprintf( pFileW, "set output './pngFiles/stressThetaCL.svg'\n");
		fprintf( pFileW, "plot for[i=1:1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 4:5 ti 'Link Stress' w l;\n\n" );
		fprintf( pFileW, "set title \"Spring Element Stress vs. Theta Graph\"\n"); 
		fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
		fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
		fprintf( pFileW, "set xrange [0:360]\n");
		fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
		fprintf( pFileW, "set output './pngFiles/stressThetaSE.svg'\n");
		fprintf( pFileW, "plot for[i=1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 2:3 ti 'Spring Stress' w l;\n\n" );

		fprintf( pFileW, "set title \"Cohesive Link Damage vs. Theta Graph\"\n"); 
		fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
		fprintf( pFileW, "set ylabel \"Damage\"\n" );
		fprintf( pFileW, "set xrange [0:360]\n");
		fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
		fprintf( pFileW, "set output './pngFiles/stressThetaCLD.svg'\n");
		fprintf( pFileW, "plot for[i=1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 4:6 ti 'Damage' w l;\n\n" );

		fclose( pFileW );
	}

    // Prepare Gnuplot data file
	if (_numprocs == 1) {
		_SThetaFile = _path+"/datFiles/stresstheta.dat";		//../results
	} else {
		_SThetaFile = _path+"/datFiles/stresstheta_" + convertInt(_myid) + ".dat";		//../results
	}
	if (_myid == 0) {	
	    FILE * pFile;
	    pFile = fopen( _SThetaFile.c_str(), "w" );
	    	fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
	    fprintf( pFile, " -- MH [DCML] (2010)\n" );
	    fprintf( pFile, "# Fragmentation Information\n" );
	    fprintf( pFile, "#Time       SprTheta    SprStress   CohTheta    CohStress           i         _Nt\n" );
	    fclose( pFile );
	}
}

void CartRing::display ( const unsigned timStepNumElas,
                     const unsigned timStepNumFrac ) {

    _DisplayFlag = true;
    _DtPrintElas = timStepNumElas;
    _DtPrintFrac = timStepNumFrac;
}

/*------------------------------ P R I V A T E -------------------------------*/

void CartRing::printConnec () const {
	if (_myid > 0) return;
    if ( _Nx < 10 ) {
        printf ( "|--------------------------------------|\n" );
        printf ( "|           Connectivities             |\n" );
        printf ( "|--------------------------------------|\n" );
        printf ( "|      Springs     |   Cohesive Zones  |\n" );
        printf ( "|   n1         n2  |   n1          n2  |\n" );
        printf ( "|------------------|-------------------|\n" );
        for ( unsigned j = 0; j < _Nx; j++ ) {
            printf ( "|   %2d         %2d  |   %2d          %2d  |\n",
                     _SprCon[j].first, _SprCon[j].second,
                     _CohCon[j].first, _CohCon[j].second );
        }
        printf ( "|------------------|-------------------|\n" );
    }
}

void CartRing::printVtk ( const unsigned timStepNum ) const {

    // Build a name for the vtk file
    std::string resuPath = _path+"/vtkFiles/";			//../results
    unsigned zeroNum = 6 - (unsigned) floor( log10( timStepNum ) );
    std::string baseName = "ring_" + convertInt(_myid) + "_";
    for ( unsigned i = 0; i < zeroNum; i++ ) {
        baseName += "0";
    }
    baseName += convertInt(timStepNum);
    std::string vtkFile = resuPath + baseName + ".vtk";

    // Print in the vtk file
    printHeader ( vtkFile );
    printMesh ( vtkFile );
    printPointData ( vtkFile );
    printCellData ( vtkFile );
}

void CartRing::printHeader ( const std::string& vtkFile ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "w" );
    fprintf ( pFile, "# vtk DataFile Version 2.0\n" );
    fprintf ( pFile, "Generated by <ring.h> -- MH [DCML] (2010)\n" );
    fprintf ( pFile, "ASCII\nDATASET UNSTRUCTURED_GRID\n\n" );
    fclose( pFile );
}

void CartRing::printMesh ( const std::string& vtkFile ) const {
	int var = 0;
	if (_myid == 0) var += 1;
	if (_myid == _numprocs-1) var += -1;

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    unsigned nodSize = _NodPos.size();
    fprintf ( pFile, "POINTS %d float\n", (_end-_begin+1)*2+var  );
    if (_local[0] && _numprocs == 1) fprintf ( pFile, " %12.3e %12.3e %12.3e\n", _NodPosOrig[0][0], _NodPosOrig[0][1], 0.0 );
    for ( unsigned i = 1; i < nodSize; i++ ) {
		if (!_local[i]) continue;
        double x = _NodPosOrig[i][0];			//NodPos
        double y = _NodPosOrig[i][1];
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", x, y, 0.0 );
    }
    if (_local[0] && _numprocs > 1) fprintf ( pFile, " %12.3e %12.3e %12.3e\n", _NodPosOrig[0][0], _NodPosOrig[0][1], 0.0 );
    unsigned sprSize = _end-_begin+1;//_SprCon.size();
    fprintf ( pFile, "\nCELLS %d %d\n", sprSize, 3*sprSize );
    for ( unsigned i = _begin; i <= _end; i++ ) {
        fprintf ( pFile, " %12d %12d %12d\n", 2, _SprCon[i].first,
                  _SprCon[i].second );
    }
    fprintf ( pFile, "\nCELL_TYPES %d\n", sprSize );
    for ( unsigned i = _begin; i <= _end; i++ ) {
        fprintf ( pFile, " %12d\n", 3 );
    }
    fprintf ( pFile, "\n" );
    fclose( pFile );
}

void CartRing::printPointData ( const std::string& vtkFile ) const {
	int var = 0;
	if (_myid == 0) var += 1;
	if (_myid == _numprocs-1) var += -1;

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    //int pointData = _NodPos.size();
    fprintf ( pFile, "POINT_DATA %d", (_end-_begin+1)*2 +var);
    fprintf ( pFile, "\nVECTORS displacements float\n" );
    if (_local[0] && _numprocs == 1) fprintf ( pFile, " %12.3e %12.3e %12.3e\n", _NodPos[0][0]-_NodPosOrig[0][0], _NodPos[0][1]-_NodPosOrig[0][1], 0.0 );
    for ( unsigned i = 1; i < _Dis.size(); i++ ) {
		if (!_local[i]) continue;
        double dx = _NodPos[i][0]-_NodPosOrig[i][0];	//Dis[i][0][0]
        double dy = _NodPos[i][1]-_NodPosOrig[i][1];
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", dx, dy, 0.0 );
    }
    if (_local[0] && _numprocs > 1) fprintf ( pFile, " %12.3e %12.3e %12.3e\n", _NodPos[0][0]-_NodPosOrig[0][0], _NodPos[0][1]-_NodPosOrig[0][1], 0.0 );
    fprintf ( pFile, "\nVECTORS velocities float\n" );
    if (_local[0] && _numprocs == 1) fprintf ( pFile, " %12.3e %12.3e %12.3e\n", _Vel[0][0][0], _Vel[0][0][1], 0.0 );
    for ( unsigned i = 1; i < _Vel.size(); i++ ) {
		if (!_local[i]) continue;
        double vx = _Vel[i][0][0];
        double vy = _Vel[i][0][1];
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", vx, vy, 0.0 );
    }
    if (_local[0] && _numprocs > 1) fprintf ( pFile, " %12.3e %12.3e %12.3e\n", _Vel[0][0][0], _Vel[0][0][1], 0.0 );
    fprintf ( pFile, "\n" );
    fclose( pFile );
}

void CartRing::printCellData ( const std::string& vtkFile ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    fprintf( pFile, "CELL_DATA %d", (_end-_begin+1) );
    fprintf( pFile, "\nSCALARS stress float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = _begin; i <= _end; i++ ) {
        fprintf( pFile, " %12.3e\n", _Stress[i] );
    }
    fprintf( pFile, "\n" );
    fclose( pFile );
}

void CartRing::printNodalInfo () const {

    if ( _NodesToPlot.size() > 0 ) {
        FILE * pFile;

        for ( unsigned i = 0; i < _NodesToPlot.size(); i++ ) {
            unsigned nodNum = _NodesToPlot[i];
			if (!_local[nodNum]) continue;
            double v_r = cosTheta( nodNum ) * _Vel[nodNum][0][0]
                       + sinTheta( nodNum ) * _Vel[nodNum][0][1];
            double v_t = cosTheta( nodNum ) * _Vel[nodNum][0][1]
                       - sinTheta( nodNum ) * _Vel[nodNum][0][0];
            pFile = fopen( _NodeFiles[i].c_str(), "a" );
            fprintf( pFile, "%12.3e", _T );
            fprintf( pFile, "%12.3e", v_r );
            fprintf( pFile, "%12.3e", v_t );
            fprintf( pFile, "\n" );
            fflush( pFile );
            fclose( pFile );
        }
    }
}

void CartRing::printElmInfo () const {

    if ( _ElmsToPlot.size() > 0 ) {
        FILE * pFile;

        for ( unsigned i = 0; i < _ElmsToPlot.size(); i++ ) {
            unsigned elmNum = _ElmsToPlot[i];
			if (elmNum < _begin || elmNum > _end) continue;
            pFile = fopen( _ElmFiles[i].c_str(), "a" );
            fprintf( pFile, "%12.3e", _T );
            fprintf( pFile, "%12.3e", _Stress[elmNum] );
            fprintf( pFile, "\n" );
            fclose( pFile );
        }
    }
}

void CartRing::printGlobalInfo () const {

    if ( _EnrgFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _EnrgFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", _T );
        fprintf( pFile, "%12.3e", _Wspr );
        fprintf( pFile, "%12.3e", _Wcoh[0] );
        fprintf( pFile, "%12.3e", _Wcoh[1] );
        fprintf( pFile, "%12.3e", _WextT );
        fprintf( pFile, "%12.3e", _Wkin );
	fprintf( pFile, "%12.3e", _Wmax * 0.01 );
	fprintf( pFile, "%12.3e", _Wsum );
	fprintf( pFile, "%12.3f", (double)(_tFlag[1]) + .001 );	//Time-step plot
	fprintf( pFile, "%12.3e", _Dt/_Dt_c );
	fprintf( pFile, "%12.3e", _dWcoh[0]);
	fprintf( pFile, "%12.3e", _dWcoh[3]);
	fprintf( pFile, "%12.3e", _Wcoh100[2]);
	fprintf( pFile, "%12.3e", _WsprD);
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void CartRing::printCohLaw () const {

    if ( _CohLawFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _CohLawFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", _T );
		int count = 0;
		for (unsigned i = 0; i < _cLaw.size(); i++ ) {
			if (_cLaw[i] < _begin || _cLaw[i] > _end) continue;
		    fprintf( pFile, "%12.3e", _delta[ _cLaw[i] ] ); 	//delta
		    fprintf( pFile, "%12.3e", _sigCoh[ _cLaw[i] ] );	//sigma
			count++;
		}
		if (count == 0) 		    fprintf( pFile, " N/A");	//no cohesive zones on this processor.
        fprintf( pFile, "\n" );
		fclose( pFile );
    }
}

void CartRing::printFrags () const {
    unsigned cohNum =19;
    if ( _FragFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _FragFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", _T );
        fprintf( pFile, "%12u", _numFrag );
        fprintf( pFile, "%12.3f", _DSum );
        fprintf( pFile, "%12.3e", _fMean );
        fprintf( pFile, "%12.3e", _fMed );
        fprintf( pFile, "%12.3e", _fMax );
	fprintf( pFile, "%12.3e", _fMin );
	fprintf( pFile, "%12.3e", _fStDev );
	fprintf( pFile, "%12.3e", _fRange );
	fprintf( pFile, "%12.3f", _fSkew );
	fprintf( pFile, "%12.3f", _fExKurtosis );
	double SigR = _Stress[cohNum];
	double SigL = _Stress[ ((cohNum+1) % _Nx) ];
	double SigC = _sigCoh[cohNum];
	fprintf( pFile, "%12.3e", SigL );			//SigL
	fprintf( pFile, "%12.3e", SigR );			//SigR
	fprintf( pFile, "%12.3e", SigR * SigL);			//SigL*SigR
	fprintf( pFile, "%12.3e", SigC );			//SigC
	if (SigR * SigL > 0 ) {
	    fprintf( pFile, "%12.3e", SigR * SigL * SigL / fabs(SigL));	//SigL*SigR*sign(SigL)
	}
	if (_numFrag <= 10){
	    for (unsigned i = 0; i < _fragLoc.size(); i++){
		fprintf( pFile, "%12u", _fragLoc[i] );
	    }
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void CartRing::printSTheta () const {
    if ( _SThetaFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _SThetaFile.c_str(), "a" );
        //fprintf( pFile, "%12.3e", _T );
	for (unsigned i = 0; i < _Nx; i++) {
		if (i < _begin || i > _end) continue;
	    double sprTheta = (double)(360*(i+0.5))/(double)(_Nx);
	    double cohTheta = (double)(360*(i+1))/(double)(_Nx);
	    fprintf( pFile, "%12.3e", _T );
	    fprintf( pFile, "%12.3f", sprTheta );
        fprintf( pFile, "%12.3e", _Stress[i] );
        fprintf( pFile, "%12.3f", cohTheta );
        fprintf( pFile, "%12.3e", _sigCoh[i] );
        fprintf( pFile, "%12.3e", _D[i][0] );
        fprintf( pFile, "%12.3f", (double)(i) );
        fprintf( pFile, "%12.3f", (double)(_Nt) );
	    fprintf( pFile, "\n" );
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void CartRing::printClean () const {
	//if (_myid > 0) return;

    std::string cleanPath = _path+"/clean.sh";
    FILE * pFile;
    pFile = fopen( cleanPath.c_str(), "w" );
    fprintf( pFile, "#!/bin/bash\n\n" );
    fprintf( pFile, "# Go to results directory\n" );
    fprintf( pFile, "cd %s\n\n", _path.c_str() );
    fprintf( pFile, "# Remove the data files\n" );
    fprintf( pFile, "cd ./datFiles/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "cd ./automatedRuns/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "# Remove the gnuplot files\n" );
    fprintf( pFile, "cd ./gnuplot/ ; rm *.plt; cd -\n\n" );
    fprintf( pFile, "# Remove the png/svg files\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.png; cd -\n\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.svg; cd -\n\n" );
    fprintf( pFile, "# Remove the vtk files\n" );
    fprintf( pFile, "cd ./vtkFiles/; find . -name \"*.vtk\" -print0 | xargs -0 rm -f; cd -\n\n" );
    fprintf( pFile, "# Remove plot.sh\n" );
    fprintf( pFile, "rm plot.sh\n" );
    fclose( pFile );
    std::string shellCmd = "chmod u+x " + cleanPath;
    //int status = system( shellCmd.c_str() );
	system( shellCmd.c_str() );

}
